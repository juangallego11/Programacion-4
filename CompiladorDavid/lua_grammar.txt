Grammar:

Rule 0     S' -> chunk
Rule 1     chunk -> chunk2 laststat
Rule 2     chunk2 -> chunk2 stat optsemi
Rule 3     chunk2 -> stat optsemi
Rule 4     block -> chunk
Rule 5     optsemi -> empty
Rule 6     optsemi -> ;
Rule 7     stat -> LOCAL namelist = explist
Rule 8     stat -> LOCAL namelist
Rule 9     stat -> LOCAL FUNCTION name funcbody
Rule 10    stat -> FUNCTION funcname funcbody
Rule 11    stat -> FOR namelist IN explist DO block END
Rule 12    stat -> FOR name = exp , exp , exp DO block END
Rule 13    stat -> FOR name = exp , exp DO block END
Rule 14    stat -> IF exp THEN block elseiflist _else END
Rule 15    stat -> REPEAT block UNTIL exp
Rule 16    stat -> WHILE exp DO block END
Rule 17    stat -> DO block END
Rule 18    stat -> varlist = explist
Rule 19    elseiflist -> empty
Rule 20    elseiflist -> elseiflist elseif
Rule 21    elseiflist -> elseif
Rule 22    elseif -> ELSEIF exp THEN block
Rule 23    _else -> empty
Rule 24    _else -> ELSE block
Rule 25    laststat -> BREAK optsemi
Rule 26    laststat -> RETURN optsemi
Rule 27    laststat -> RETURN explist optsemi
Rule 28    funcname -> funcname2
Rule 29    funcname -> funcname2 : name
Rule 30    funcname2 -> funcname2 . name
Rule 31    funcname2 -> name
Rule 32    varlist -> var
Rule 33    varlist -> varlist , var
Rule 34    var -> prefixexp . name
Rule 35    var -> prefixexp [ exp ]
Rule 36    var -> name
Rule 37    name -> NAME
Rule 38    namelist -> name
Rule 39    namelist -> namelist , name
Rule 40    explist -> exp
Rule 41    explist -> explist , exp
Rule 42    exp -> # exp  [precedence=left, level=7]
Rule 43    exp -> NOT exp  [precedence=left, level=7]
Rule 44    exp -> - exp  [precedence=left, level=7]
Rule 45    exp -> exp OR exp  [precedence=left, level=1]
Rule 46    exp -> exp AND exp  [precedence=left, level=2]
Rule 47    exp -> exp NE exp  [precedence=left, level=3]
Rule 48    exp -> exp EQ exp  [precedence=left, level=3]
Rule 49    exp -> exp GE exp  [precedence=left, level=3]
Rule 50    exp -> exp GT exp  [precedence=left, level=3]
Rule 51    exp -> exp LE exp  [precedence=left, level=3]
Rule 52    exp -> exp LT exp  [precedence=left, level=3]
Rule 53    exp -> exp CONCAT exp  [precedence=right, level=4]
Rule 54    exp -> exp % exp  [precedence=left, level=6]
Rule 55    exp -> exp ^ exp  [precedence=right, level=8]
Rule 56    exp -> exp / exp  [precedence=left, level=6]
Rule 57    exp -> exp * exp  [precedence=left, level=6]
Rule 58    exp -> exp - exp  [precedence=left, level=5]
Rule 59    exp -> exp + exp  [precedence=left, level=5]
Rule 60    exp -> tableconstructor
Rule 61    exp -> function
Rule 62    exp -> VARARG
Rule 63    exp -> STRING
Rule 64    exp -> NUMBER
Rule 65    exp -> TRUE
Rule 66    exp -> FALSE
Rule 67    exp -> NIL
Rule 68    prefixexp -> ( exp )
Rule 69    prefixexp -> functioncall
Rule 70    prefixexp -> var
Rule 71    functioncall -> prefixexp : name args
Rule 72    functioncall -> prefixexp args
Rule 73    args -> STRING
Rule 74    args -> tableconstructor
Rule 75    args -> ( explist )
Rule 76    args -> ( )
Rule 77    function -> FUNCTION funcbody
Rule 78    funcbody -> ( ) block END
Rule 79    funcbody -> ( parlist ) block END
Rule 80    parlist -> VARARG
Rule 81    parlist -> namelist , VARARG
Rule 82    parlist -> namelist
Rule 83    tableconstructor -> { }
Rule 84    tableconstructor -> { fieldlist }
Rule 85    fieldlist -> fieldlist2 optfieldsep
Rule 86    fieldlist2 -> fieldlist2 fieldsep field
Rule 87    fieldlist2 -> field
Rule 88    field -> exp
Rule 89    field -> NAME = exp
Rule 90    field -> [ exp ] = exp
Rule 91    optfieldsep -> empty
Rule 92    optfieldsep -> fieldsep
Rule 93    fieldsep -> ;
Rule 94    fieldsep -> ,
Rule 95    empty -> <empty>

Terminals, with rules where they appear:

#                    : 42
%                    : 54
(                    : 68 75 76 78 79
)                    : 68 75 76 78 79
*                    : 57
+                    : 59
,                    : 12 12 13 33 39 41 81 94
-                    : 44 58
.                    : 30 34
/                    : 56
:                    : 29 71
;                    : 6 93
=                    : 7 12 13 18 89 90
AND                  : 46
BREAK                : 25
CONCAT               : 53
DO                   : 11 12 13 16 17
ELSE                 : 24
ELSEIF               : 22
END                  : 11 12 13 14 16 17 78 79
EQ                   : 48
FALSE                : 66
FOR                  : 11 12 13
FUNCTION             : 9 10 77
GE                   : 49
GT                   : 50
IF                   : 14
IN                   : 11
LE                   : 51
LOCAL                : 7 8 9
LT                   : 52
NAME                 : 37 89
NE                   : 47
NIL                  : 67
NOT                  : 43
NUMBER               : 64
OR                   : 45
REPEAT               : 15
RETURN               : 26 27
STRING               : 63 73
THEN                 : 14 22
TRUE                 : 65
UNTIL                : 15
VARARG               : 62 80 81
WHILE                : 16
[                    : 35 90
]                    : 35 90
^                    : 55
error                : 
{                    : 83 84
}                    : 83 84

Nonterminals, with rules where they appear:

_else                : 14
args                 : 71 72
block                : 11 12 13 14 15 16 17 22 24 78 79
chunk                : 4 0
chunk2               : 1 2
elseif               : 20 21
elseiflist           : 14 20
empty                : 5 19 23 91
exp                  : 12 12 12 13 13 14 15 16 22 35 40 41 42 43 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 68 88 89 90 90
explist              : 7 11 18 27 41 75
field                : 86 87
fieldlist            : 84
fieldlist2           : 85 86
fieldsep             : 86 92
funcbody             : 9 10 77
funcname             : 10
funcname2            : 28 29 30
function             : 61
functioncall         : 69
laststat             : 1
name                 : 9 12 13 29 30 31 34 36 38 39 71
namelist             : 7 8 11 39 81 82
optfieldsep          : 85
optsemi              : 2 3 25 26 27
parlist              : 79
prefixexp            : 34 35 71 72
stat                 : 2 3
tableconstructor     : 60 74
var                  : 32 33 70
varlist              : 18 33


state 0

    (0) S' -> . chunk
    (1) chunk -> . chunk2 laststat
    (2) chunk2 -> . chunk2 stat optsemi
    (3) chunk2 -> . stat optsemi
    (7) stat -> . LOCAL namelist = explist
    (8) stat -> . LOCAL namelist
    (9) stat -> . LOCAL FUNCTION name funcbody
    (10) stat -> . FUNCTION funcname funcbody
    (11) stat -> . FOR namelist IN explist DO block END
    (12) stat -> . FOR name = exp , exp , exp DO block END
    (13) stat -> . FOR name = exp , exp DO block END
    (14) stat -> . IF exp THEN block elseiflist _else END
    (15) stat -> . REPEAT block UNTIL exp
    (16) stat -> . WHILE exp DO block END
    (17) stat -> . DO block END
    (18) stat -> . varlist = explist
    (32) varlist -> . var
    (33) varlist -> . varlist , var
    (34) var -> . prefixexp . name
    (35) var -> . prefixexp [ exp ]
    (36) var -> . name
    (68) prefixexp -> . ( exp )
    (69) prefixexp -> . functioncall
    (70) prefixexp -> . var
    (37) name -> . NAME
    (71) functioncall -> . prefixexp : name args
    (72) functioncall -> . prefixexp args
    LOCAL           shift and go to state 4
    FUNCTION        shift and go to state 5
    FOR             shift and go to state 7
    IF              shift and go to state 9
    REPEAT          shift and go to state 10
    WHILE           shift and go to state 11
    DO              shift and go to state 8
    (               shift and go to state 15
    NAME            shift and go to state 17

    chunk                          shift and go to state 1
    chunk2                         shift and go to state 2
    stat                           shift and go to state 3
    name                           shift and go to state 6
    varlist                        shift and go to state 12
    var                            shift and go to state 13
    prefixexp                      shift and go to state 14
    functioncall                   shift and go to state 16

state 1

    (0) S' -> chunk .


state 2

    (1) chunk -> chunk2 . laststat
    (2) chunk2 -> chunk2 . stat optsemi
    (25) laststat -> . BREAK optsemi
    (26) laststat -> . RETURN optsemi
    (27) laststat -> . RETURN explist optsemi
    (7) stat -> . LOCAL namelist = explist
    (8) stat -> . LOCAL namelist
    (9) stat -> . LOCAL FUNCTION name funcbody
    (10) stat -> . FUNCTION funcname funcbody
    (11) stat -> . FOR namelist IN explist DO block END
    (12) stat -> . FOR name = exp , exp , exp DO block END
    (13) stat -> . FOR name = exp , exp DO block END
    (14) stat -> . IF exp THEN block elseiflist _else END
    (15) stat -> . REPEAT block UNTIL exp
    (16) stat -> . WHILE exp DO block END
    (17) stat -> . DO block END
    (18) stat -> . varlist = explist
    (32) varlist -> . var
    (33) varlist -> . varlist , var
    (34) var -> . prefixexp . name
    (35) var -> . prefixexp [ exp ]
    (36) var -> . name
    (68) prefixexp -> . ( exp )
    (69) prefixexp -> . functioncall
    (70) prefixexp -> . var
    (37) name -> . NAME
    (71) functioncall -> . prefixexp : name args
    (72) functioncall -> . prefixexp args
    BREAK           shift and go to state 20
    RETURN          shift and go to state 21
    LOCAL           shift and go to state 4
    FUNCTION        shift and go to state 5
    FOR             shift and go to state 7
    IF              shift and go to state 9
    REPEAT          shift and go to state 10
    WHILE           shift and go to state 11
    DO              shift and go to state 8
    (               shift and go to state 15
    NAME            shift and go to state 17

    laststat                       shift and go to state 18
    stat                           shift and go to state 19
    name                           shift and go to state 6
    varlist                        shift and go to state 12
    var                            shift and go to state 13
    prefixexp                      shift and go to state 14
    functioncall                   shift and go to state 16

state 3

    (3) chunk2 -> stat . optsemi
    (5) optsemi -> . empty
    (6) optsemi -> . ;
    (95) empty -> .
    ;               shift and go to state 24
    BREAK           reduce using rule 95 (empty -> .)
    RETURN          reduce using rule 95 (empty -> .)
    LOCAL           reduce using rule 95 (empty -> .)
    FUNCTION        reduce using rule 95 (empty -> .)
    FOR             reduce using rule 95 (empty -> .)
    IF              reduce using rule 95 (empty -> .)
    REPEAT          reduce using rule 95 (empty -> .)
    WHILE           reduce using rule 95 (empty -> .)
    DO              reduce using rule 95 (empty -> .)
    (               reduce using rule 95 (empty -> .)
    NAME            reduce using rule 95 (empty -> .)

    optsemi                        shift and go to state 22
    empty                          shift and go to state 23

state 4

    (7) stat -> LOCAL . namelist = explist
    (8) stat -> LOCAL . namelist
    (9) stat -> LOCAL . FUNCTION name funcbody
    (38) namelist -> . name
    (39) namelist -> . namelist , name
    (37) name -> . NAME
    FUNCTION        shift and go to state 26
    NAME            shift and go to state 17

    namelist                       shift and go to state 25
    name                           shift and go to state 27

state 5

    (10) stat -> FUNCTION . funcname funcbody
    (28) funcname -> . funcname2
    (29) funcname -> . funcname2 : name
    (30) funcname2 -> . funcname2 . name
    (31) funcname2 -> . name
    (37) name -> . NAME
    NAME            shift and go to state 17

    funcname                       shift and go to state 28
    funcname2                      shift and go to state 29
    name                           shift and go to state 30

state 6

    (36) var -> name .
    =               reduce using rule 36 (var -> name .)
    ,               reduce using rule 36 (var -> name .)
    .               reduce using rule 36 (var -> name .)
    [               reduce using rule 36 (var -> name .)
    :               reduce using rule 36 (var -> name .)
    STRING          reduce using rule 36 (var -> name .)
    (               reduce using rule 36 (var -> name .)
    {               reduce using rule 36 (var -> name .)


state 7

    (11) stat -> FOR . namelist IN explist DO block END
    (12) stat -> FOR . name = exp , exp , exp DO block END
    (13) stat -> FOR . name = exp , exp DO block END
    (38) namelist -> . name
    (39) namelist -> . namelist , name
    (37) name -> . NAME
    NAME            shift and go to state 17

    namelist                       shift and go to state 31
    name                           shift and go to state 32

state 8

    (17) stat -> DO . block END
    (4) block -> . chunk
    (1) chunk -> . chunk2 laststat
    (2) chunk2 -> . chunk2 stat optsemi
    (3) chunk2 -> . stat optsemi
    (7) stat -> . LOCAL namelist = explist
    (8) stat -> . LOCAL namelist
    (9) stat -> . LOCAL FUNCTION name funcbody
    (10) stat -> . FUNCTION funcname funcbody
    (11) stat -> . FOR namelist IN explist DO block END
    (12) stat -> . FOR name = exp , exp , exp DO block END
    (13) stat -> . FOR name = exp , exp DO block END
    (14) stat -> . IF exp THEN block elseiflist _else END
    (15) stat -> . REPEAT block UNTIL exp
    (16) stat -> . WHILE exp DO block END
    (17) stat -> . DO block END
    (18) stat -> . varlist = explist
    (32) varlist -> . var
    (33) varlist -> . varlist , var
    (34) var -> . prefixexp . name
    (35) var -> . prefixexp [ exp ]
    (36) var -> . name
    (68) prefixexp -> . ( exp )
    (69) prefixexp -> . functioncall
    (70) prefixexp -> . var
    (37) name -> . NAME
    (71) functioncall -> . prefixexp : name args
    (72) functioncall -> . prefixexp args
    LOCAL           shift and go to state 4
    FUNCTION        shift and go to state 5
    FOR             shift and go to state 7
    IF              shift and go to state 9
    REPEAT          shift and go to state 10
    WHILE           shift and go to state 11
    DO              shift and go to state 8
    (               shift and go to state 15
    NAME            shift and go to state 17

    block                          shift and go to state 33
    chunk                          shift and go to state 34
    chunk2                         shift and go to state 2
    stat                           shift and go to state 3
    name                           shift and go to state 6
    varlist                        shift and go to state 12
    var                            shift and go to state 13
    prefixexp                      shift and go to state 14
    functioncall                   shift and go to state 16

state 9

    (14) stat -> IF . exp THEN block elseiflist _else END
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 35
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 10

    (15) stat -> REPEAT . block UNTIL exp
    (4) block -> . chunk
    (1) chunk -> . chunk2 laststat
    (2) chunk2 -> . chunk2 stat optsemi
    (3) chunk2 -> . stat optsemi
    (7) stat -> . LOCAL namelist = explist
    (8) stat -> . LOCAL namelist
    (9) stat -> . LOCAL FUNCTION name funcbody
    (10) stat -> . FUNCTION funcname funcbody
    (11) stat -> . FOR namelist IN explist DO block END
    (12) stat -> . FOR name = exp , exp , exp DO block END
    (13) stat -> . FOR name = exp , exp DO block END
    (14) stat -> . IF exp THEN block elseiflist _else END
    (15) stat -> . REPEAT block UNTIL exp
    (16) stat -> . WHILE exp DO block END
    (17) stat -> . DO block END
    (18) stat -> . varlist = explist
    (32) varlist -> . var
    (33) varlist -> . varlist , var
    (34) var -> . prefixexp . name
    (35) var -> . prefixexp [ exp ]
    (36) var -> . name
    (68) prefixexp -> . ( exp )
    (69) prefixexp -> . functioncall
    (70) prefixexp -> . var
    (37) name -> . NAME
    (71) functioncall -> . prefixexp : name args
    (72) functioncall -> . prefixexp args
    LOCAL           shift and go to state 4
    FUNCTION        shift and go to state 5
    FOR             shift and go to state 7
    IF              shift and go to state 9
    REPEAT          shift and go to state 10
    WHILE           shift and go to state 11
    DO              shift and go to state 8
    (               shift and go to state 15
    NAME            shift and go to state 17

    block                          shift and go to state 49
    chunk                          shift and go to state 34
    chunk2                         shift and go to state 2
    stat                           shift and go to state 3
    name                           shift and go to state 6
    varlist                        shift and go to state 12
    var                            shift and go to state 13
    prefixexp                      shift and go to state 14
    functioncall                   shift and go to state 16

state 11

    (16) stat -> WHILE . exp DO block END
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 50
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 12

    (18) stat -> varlist . = explist
    (33) varlist -> varlist . , var
    =               shift and go to state 51
    ,               shift and go to state 52


state 13

    (32) varlist -> var .
    (70) prefixexp -> var .
    =               reduce using rule 32 (varlist -> var .)
    ,               reduce using rule 32 (varlist -> var .)
    .               reduce using rule 70 (prefixexp -> var .)
    [               reduce using rule 70 (prefixexp -> var .)
    :               reduce using rule 70 (prefixexp -> var .)
    STRING          reduce using rule 70 (prefixexp -> var .)
    (               reduce using rule 70 (prefixexp -> var .)
    {               reduce using rule 70 (prefixexp -> var .)


state 14

    (34) var -> prefixexp . . name
    (35) var -> prefixexp . [ exp ]
    (71) functioncall -> prefixexp . : name args
    (72) functioncall -> prefixexp . args
    (73) args -> . STRING
    (74) args -> . tableconstructor
    (75) args -> . ( explist )
    (76) args -> . ( )
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    .               shift and go to state 53
    [               shift and go to state 54
    :               shift and go to state 55
    STRING          shift and go to state 57
    (               shift and go to state 59
    {               shift and go to state 47

    args                           shift and go to state 56
    tableconstructor               shift and go to state 58

state 15

    (68) prefixexp -> ( . exp )
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 60
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 16

    (69) prefixexp -> functioncall .
    .               reduce using rule 69 (prefixexp -> functioncall .)
    [               reduce using rule 69 (prefixexp -> functioncall .)
    :               reduce using rule 69 (prefixexp -> functioncall .)
    STRING          reduce using rule 69 (prefixexp -> functioncall .)
    (               reduce using rule 69 (prefixexp -> functioncall .)
    {               reduce using rule 69 (prefixexp -> functioncall .)


state 17

    (37) name -> NAME .
    =               reduce using rule 37 (name -> NAME .)
    ,               reduce using rule 37 (name -> NAME .)
    .               reduce using rule 37 (name -> NAME .)
    [               reduce using rule 37 (name -> NAME .)
    :               reduce using rule 37 (name -> NAME .)
    STRING          reduce using rule 37 (name -> NAME .)
    (               reduce using rule 37 (name -> NAME .)
    {               reduce using rule 37 (name -> NAME .)
    ;               reduce using rule 37 (name -> NAME .)
    BREAK           reduce using rule 37 (name -> NAME .)
    RETURN          reduce using rule 37 (name -> NAME .)
    LOCAL           reduce using rule 37 (name -> NAME .)
    FUNCTION        reduce using rule 37 (name -> NAME .)
    FOR             reduce using rule 37 (name -> NAME .)
    IF              reduce using rule 37 (name -> NAME .)
    REPEAT          reduce using rule 37 (name -> NAME .)
    WHILE           reduce using rule 37 (name -> NAME .)
    DO              reduce using rule 37 (name -> NAME .)
    NAME            reduce using rule 37 (name -> NAME .)
    IN              reduce using rule 37 (name -> NAME .)
    )               reduce using rule 37 (name -> NAME .)


state 18

    (1) chunk -> chunk2 laststat .
    $end            reduce using rule 1 (chunk -> chunk2 laststat .)
    END             reduce using rule 1 (chunk -> chunk2 laststat .)
    UNTIL           reduce using rule 1 (chunk -> chunk2 laststat .)
    ELSEIF          reduce using rule 1 (chunk -> chunk2 laststat .)
    ELSE            reduce using rule 1 (chunk -> chunk2 laststat .)


state 19

    (2) chunk2 -> chunk2 stat . optsemi
    (5) optsemi -> . empty
    (6) optsemi -> . ;
    (95) empty -> .
    ;               shift and go to state 24
    BREAK           reduce using rule 95 (empty -> .)
    RETURN          reduce using rule 95 (empty -> .)
    LOCAL           reduce using rule 95 (empty -> .)
    FUNCTION        reduce using rule 95 (empty -> .)
    FOR             reduce using rule 95 (empty -> .)
    IF              reduce using rule 95 (empty -> .)
    REPEAT          reduce using rule 95 (empty -> .)
    WHILE           reduce using rule 95 (empty -> .)
    DO              reduce using rule 95 (empty -> .)
    (               reduce using rule 95 (empty -> .)
    NAME            reduce using rule 95 (empty -> .)

    optsemi                        shift and go to state 61
    empty                          shift and go to state 23

state 20

    (25) laststat -> BREAK . optsemi
    (5) optsemi -> . empty
    (6) optsemi -> . ;
    (95) empty -> .
    ;               shift and go to state 24
    $end            reduce using rule 95 (empty -> .)
    END             reduce using rule 95 (empty -> .)
    UNTIL           reduce using rule 95 (empty -> .)
    ELSEIF          reduce using rule 95 (empty -> .)
    ELSE            reduce using rule 95 (empty -> .)

    optsemi                        shift and go to state 62
    empty                          shift and go to state 23

state 21

    (26) laststat -> RETURN . optsemi
    (27) laststat -> RETURN . explist optsemi
    (5) optsemi -> . empty
    (6) optsemi -> . ;
    (40) explist -> . exp
    (41) explist -> . explist , exp
    (95) empty -> .
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    ;               shift and go to state 24
    $end            reduce using rule 95 (empty -> .)
    END             reduce using rule 95 (empty -> .)
    UNTIL           reduce using rule 95 (empty -> .)
    ELSEIF          reduce using rule 95 (empty -> .)
    ELSE            reduce using rule 95 (empty -> .)
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    optsemi                        shift and go to state 63
    explist                        shift and go to state 64
    empty                          shift and go to state 23
    exp                            shift and go to state 65
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 22

    (3) chunk2 -> stat optsemi .
    BREAK           reduce using rule 3 (chunk2 -> stat optsemi .)
    RETURN          reduce using rule 3 (chunk2 -> stat optsemi .)
    LOCAL           reduce using rule 3 (chunk2 -> stat optsemi .)
    FUNCTION        reduce using rule 3 (chunk2 -> stat optsemi .)
    FOR             reduce using rule 3 (chunk2 -> stat optsemi .)
    IF              reduce using rule 3 (chunk2 -> stat optsemi .)
    REPEAT          reduce using rule 3 (chunk2 -> stat optsemi .)
    WHILE           reduce using rule 3 (chunk2 -> stat optsemi .)
    DO              reduce using rule 3 (chunk2 -> stat optsemi .)
    (               reduce using rule 3 (chunk2 -> stat optsemi .)
    NAME            reduce using rule 3 (chunk2 -> stat optsemi .)


state 23

    (5) optsemi -> empty .
    BREAK           reduce using rule 5 (optsemi -> empty .)
    RETURN          reduce using rule 5 (optsemi -> empty .)
    LOCAL           reduce using rule 5 (optsemi -> empty .)
    FUNCTION        reduce using rule 5 (optsemi -> empty .)
    FOR             reduce using rule 5 (optsemi -> empty .)
    IF              reduce using rule 5 (optsemi -> empty .)
    REPEAT          reduce using rule 5 (optsemi -> empty .)
    WHILE           reduce using rule 5 (optsemi -> empty .)
    DO              reduce using rule 5 (optsemi -> empty .)
    (               reduce using rule 5 (optsemi -> empty .)
    NAME            reduce using rule 5 (optsemi -> empty .)
    $end            reduce using rule 5 (optsemi -> empty .)
    END             reduce using rule 5 (optsemi -> empty .)
    UNTIL           reduce using rule 5 (optsemi -> empty .)
    ELSEIF          reduce using rule 5 (optsemi -> empty .)
    ELSE            reduce using rule 5 (optsemi -> empty .)


state 24

    (6) optsemi -> ; .
    BREAK           reduce using rule 6 (optsemi -> ; .)
    RETURN          reduce using rule 6 (optsemi -> ; .)
    LOCAL           reduce using rule 6 (optsemi -> ; .)
    FUNCTION        reduce using rule 6 (optsemi -> ; .)
    FOR             reduce using rule 6 (optsemi -> ; .)
    IF              reduce using rule 6 (optsemi -> ; .)
    REPEAT          reduce using rule 6 (optsemi -> ; .)
    WHILE           reduce using rule 6 (optsemi -> ; .)
    DO              reduce using rule 6 (optsemi -> ; .)
    (               reduce using rule 6 (optsemi -> ; .)
    NAME            reduce using rule 6 (optsemi -> ; .)
    $end            reduce using rule 6 (optsemi -> ; .)
    END             reduce using rule 6 (optsemi -> ; .)
    UNTIL           reduce using rule 6 (optsemi -> ; .)
    ELSEIF          reduce using rule 6 (optsemi -> ; .)
    ELSE            reduce using rule 6 (optsemi -> ; .)


state 25

    (7) stat -> LOCAL namelist . = explist
    (8) stat -> LOCAL namelist .
    (39) namelist -> namelist . , name
    =               shift and go to state 66
    ;               reduce using rule 8 (stat -> LOCAL namelist .)
    BREAK           reduce using rule 8 (stat -> LOCAL namelist .)
    RETURN          reduce using rule 8 (stat -> LOCAL namelist .)
    LOCAL           reduce using rule 8 (stat -> LOCAL namelist .)
    FUNCTION        reduce using rule 8 (stat -> LOCAL namelist .)
    FOR             reduce using rule 8 (stat -> LOCAL namelist .)
    IF              reduce using rule 8 (stat -> LOCAL namelist .)
    REPEAT          reduce using rule 8 (stat -> LOCAL namelist .)
    WHILE           reduce using rule 8 (stat -> LOCAL namelist .)
    DO              reduce using rule 8 (stat -> LOCAL namelist .)
    (               reduce using rule 8 (stat -> LOCAL namelist .)
    NAME            reduce using rule 8 (stat -> LOCAL namelist .)
    ,               shift and go to state 67


state 26

    (9) stat -> LOCAL FUNCTION . name funcbody
    (37) name -> . NAME
    NAME            shift and go to state 17

    name                           shift and go to state 68

state 27

    (38) namelist -> name .
    =               reduce using rule 38 (namelist -> name .)
    ,               reduce using rule 38 (namelist -> name .)
    ;               reduce using rule 38 (namelist -> name .)
    BREAK           reduce using rule 38 (namelist -> name .)
    RETURN          reduce using rule 38 (namelist -> name .)
    LOCAL           reduce using rule 38 (namelist -> name .)
    FUNCTION        reduce using rule 38 (namelist -> name .)
    FOR             reduce using rule 38 (namelist -> name .)
    IF              reduce using rule 38 (namelist -> name .)
    REPEAT          reduce using rule 38 (namelist -> name .)
    WHILE           reduce using rule 38 (namelist -> name .)
    DO              reduce using rule 38 (namelist -> name .)
    (               reduce using rule 38 (namelist -> name .)
    NAME            reduce using rule 38 (namelist -> name .)
    )               reduce using rule 38 (namelist -> name .)


state 28

    (10) stat -> FUNCTION funcname . funcbody
    (78) funcbody -> . ( ) block END
    (79) funcbody -> . ( parlist ) block END
    (               shift and go to state 70

    funcbody                       shift and go to state 69

state 29

    (28) funcname -> funcname2 .
    (29) funcname -> funcname2 . : name
    (30) funcname2 -> funcname2 . . name
    (               reduce using rule 28 (funcname -> funcname2 .)
    :               shift and go to state 71
    .               shift and go to state 72


state 30

    (31) funcname2 -> name .
    :               reduce using rule 31 (funcname2 -> name .)
    .               reduce using rule 31 (funcname2 -> name .)
    (               reduce using rule 31 (funcname2 -> name .)


state 31

    (11) stat -> FOR namelist . IN explist DO block END
    (39) namelist -> namelist . , name
    IN              shift and go to state 73
    ,               shift and go to state 67


state 32

    (12) stat -> FOR name . = exp , exp , exp DO block END
    (13) stat -> FOR name . = exp , exp DO block END
    (38) namelist -> name .
    =               shift and go to state 74
    IN              reduce using rule 38 (namelist -> name .)
    ,               reduce using rule 38 (namelist -> name .)


state 33

    (17) stat -> DO block . END
    END             shift and go to state 75


state 34

    (4) block -> chunk .
    END             reduce using rule 4 (block -> chunk .)
    UNTIL           reduce using rule 4 (block -> chunk .)
    ELSEIF          reduce using rule 4 (block -> chunk .)
    ELSE            reduce using rule 4 (block -> chunk .)


state 35

    (14) stat -> IF exp . THEN block elseiflist _else END
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    THEN            shift and go to state 76
    OR              shift and go to state 77
    AND             shift and go to state 78
    NE              shift and go to state 79
    EQ              shift and go to state 80
    GE              shift and go to state 81
    GT              shift and go to state 82
    LE              shift and go to state 83
    LT              shift and go to state 84
    CONCAT          shift and go to state 85
    %               shift and go to state 86
    ^               shift and go to state 87
    /               shift and go to state 88
    *               shift and go to state 89
    -               shift and go to state 90
    +               shift and go to state 91


state 36

    (42) exp -> # . exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 92
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 37

    (43) exp -> NOT . exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 93
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 38

    (44) exp -> - . exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 94
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 39

    (60) exp -> tableconstructor .
    THEN            reduce using rule 60 (exp -> tableconstructor .)
    OR              reduce using rule 60 (exp -> tableconstructor .)
    AND             reduce using rule 60 (exp -> tableconstructor .)
    NE              reduce using rule 60 (exp -> tableconstructor .)
    EQ              reduce using rule 60 (exp -> tableconstructor .)
    GE              reduce using rule 60 (exp -> tableconstructor .)
    GT              reduce using rule 60 (exp -> tableconstructor .)
    LE              reduce using rule 60 (exp -> tableconstructor .)
    LT              reduce using rule 60 (exp -> tableconstructor .)
    CONCAT          reduce using rule 60 (exp -> tableconstructor .)
    %               reduce using rule 60 (exp -> tableconstructor .)
    ^               reduce using rule 60 (exp -> tableconstructor .)
    /               reduce using rule 60 (exp -> tableconstructor .)
    *               reduce using rule 60 (exp -> tableconstructor .)
    -               reduce using rule 60 (exp -> tableconstructor .)
    +               reduce using rule 60 (exp -> tableconstructor .)
    DO              reduce using rule 60 (exp -> tableconstructor .)
    )               reduce using rule 60 (exp -> tableconstructor .)
    ,               reduce using rule 60 (exp -> tableconstructor .)
    ;               reduce using rule 60 (exp -> tableconstructor .)
    $end            reduce using rule 60 (exp -> tableconstructor .)
    END             reduce using rule 60 (exp -> tableconstructor .)
    UNTIL           reduce using rule 60 (exp -> tableconstructor .)
    ELSEIF          reduce using rule 60 (exp -> tableconstructor .)
    ELSE            reduce using rule 60 (exp -> tableconstructor .)
    }               reduce using rule 60 (exp -> tableconstructor .)
    BREAK           reduce using rule 60 (exp -> tableconstructor .)
    RETURN          reduce using rule 60 (exp -> tableconstructor .)
    LOCAL           reduce using rule 60 (exp -> tableconstructor .)
    FUNCTION        reduce using rule 60 (exp -> tableconstructor .)
    FOR             reduce using rule 60 (exp -> tableconstructor .)
    IF              reduce using rule 60 (exp -> tableconstructor .)
    REPEAT          reduce using rule 60 (exp -> tableconstructor .)
    WHILE           reduce using rule 60 (exp -> tableconstructor .)
    (               reduce using rule 60 (exp -> tableconstructor .)
    NAME            reduce using rule 60 (exp -> tableconstructor .)
    ]               reduce using rule 60 (exp -> tableconstructor .)


state 40

    (61) exp -> function .
    THEN            reduce using rule 61 (exp -> function .)
    OR              reduce using rule 61 (exp -> function .)
    AND             reduce using rule 61 (exp -> function .)
    NE              reduce using rule 61 (exp -> function .)
    EQ              reduce using rule 61 (exp -> function .)
    GE              reduce using rule 61 (exp -> function .)
    GT              reduce using rule 61 (exp -> function .)
    LE              reduce using rule 61 (exp -> function .)
    LT              reduce using rule 61 (exp -> function .)
    CONCAT          reduce using rule 61 (exp -> function .)
    %               reduce using rule 61 (exp -> function .)
    ^               reduce using rule 61 (exp -> function .)
    /               reduce using rule 61 (exp -> function .)
    *               reduce using rule 61 (exp -> function .)
    -               reduce using rule 61 (exp -> function .)
    +               reduce using rule 61 (exp -> function .)
    DO              reduce using rule 61 (exp -> function .)
    )               reduce using rule 61 (exp -> function .)
    ,               reduce using rule 61 (exp -> function .)
    ;               reduce using rule 61 (exp -> function .)
    $end            reduce using rule 61 (exp -> function .)
    END             reduce using rule 61 (exp -> function .)
    UNTIL           reduce using rule 61 (exp -> function .)
    ELSEIF          reduce using rule 61 (exp -> function .)
    ELSE            reduce using rule 61 (exp -> function .)
    }               reduce using rule 61 (exp -> function .)
    BREAK           reduce using rule 61 (exp -> function .)
    RETURN          reduce using rule 61 (exp -> function .)
    LOCAL           reduce using rule 61 (exp -> function .)
    FUNCTION        reduce using rule 61 (exp -> function .)
    FOR             reduce using rule 61 (exp -> function .)
    IF              reduce using rule 61 (exp -> function .)
    REPEAT          reduce using rule 61 (exp -> function .)
    WHILE           reduce using rule 61 (exp -> function .)
    (               reduce using rule 61 (exp -> function .)
    NAME            reduce using rule 61 (exp -> function .)
    ]               reduce using rule 61 (exp -> function .)


state 41

    (62) exp -> VARARG .
    THEN            reduce using rule 62 (exp -> VARARG .)
    OR              reduce using rule 62 (exp -> VARARG .)
    AND             reduce using rule 62 (exp -> VARARG .)
    NE              reduce using rule 62 (exp -> VARARG .)
    EQ              reduce using rule 62 (exp -> VARARG .)
    GE              reduce using rule 62 (exp -> VARARG .)
    GT              reduce using rule 62 (exp -> VARARG .)
    LE              reduce using rule 62 (exp -> VARARG .)
    LT              reduce using rule 62 (exp -> VARARG .)
    CONCAT          reduce using rule 62 (exp -> VARARG .)
    %               reduce using rule 62 (exp -> VARARG .)
    ^               reduce using rule 62 (exp -> VARARG .)
    /               reduce using rule 62 (exp -> VARARG .)
    *               reduce using rule 62 (exp -> VARARG .)
    -               reduce using rule 62 (exp -> VARARG .)
    +               reduce using rule 62 (exp -> VARARG .)
    DO              reduce using rule 62 (exp -> VARARG .)
    )               reduce using rule 62 (exp -> VARARG .)
    ,               reduce using rule 62 (exp -> VARARG .)
    ;               reduce using rule 62 (exp -> VARARG .)
    $end            reduce using rule 62 (exp -> VARARG .)
    END             reduce using rule 62 (exp -> VARARG .)
    UNTIL           reduce using rule 62 (exp -> VARARG .)
    ELSEIF          reduce using rule 62 (exp -> VARARG .)
    ELSE            reduce using rule 62 (exp -> VARARG .)
    }               reduce using rule 62 (exp -> VARARG .)
    BREAK           reduce using rule 62 (exp -> VARARG .)
    RETURN          reduce using rule 62 (exp -> VARARG .)
    LOCAL           reduce using rule 62 (exp -> VARARG .)
    FUNCTION        reduce using rule 62 (exp -> VARARG .)
    FOR             reduce using rule 62 (exp -> VARARG .)
    IF              reduce using rule 62 (exp -> VARARG .)
    REPEAT          reduce using rule 62 (exp -> VARARG .)
    WHILE           reduce using rule 62 (exp -> VARARG .)
    (               reduce using rule 62 (exp -> VARARG .)
    NAME            reduce using rule 62 (exp -> VARARG .)
    ]               reduce using rule 62 (exp -> VARARG .)


state 42

    (63) exp -> STRING .
    THEN            reduce using rule 63 (exp -> STRING .)
    OR              reduce using rule 63 (exp -> STRING .)
    AND             reduce using rule 63 (exp -> STRING .)
    NE              reduce using rule 63 (exp -> STRING .)
    EQ              reduce using rule 63 (exp -> STRING .)
    GE              reduce using rule 63 (exp -> STRING .)
    GT              reduce using rule 63 (exp -> STRING .)
    LE              reduce using rule 63 (exp -> STRING .)
    LT              reduce using rule 63 (exp -> STRING .)
    CONCAT          reduce using rule 63 (exp -> STRING .)
    %               reduce using rule 63 (exp -> STRING .)
    ^               reduce using rule 63 (exp -> STRING .)
    /               reduce using rule 63 (exp -> STRING .)
    *               reduce using rule 63 (exp -> STRING .)
    -               reduce using rule 63 (exp -> STRING .)
    +               reduce using rule 63 (exp -> STRING .)
    DO              reduce using rule 63 (exp -> STRING .)
    )               reduce using rule 63 (exp -> STRING .)
    ,               reduce using rule 63 (exp -> STRING .)
    ;               reduce using rule 63 (exp -> STRING .)
    $end            reduce using rule 63 (exp -> STRING .)
    END             reduce using rule 63 (exp -> STRING .)
    UNTIL           reduce using rule 63 (exp -> STRING .)
    ELSEIF          reduce using rule 63 (exp -> STRING .)
    ELSE            reduce using rule 63 (exp -> STRING .)
    }               reduce using rule 63 (exp -> STRING .)
    BREAK           reduce using rule 63 (exp -> STRING .)
    RETURN          reduce using rule 63 (exp -> STRING .)
    LOCAL           reduce using rule 63 (exp -> STRING .)
    FUNCTION        reduce using rule 63 (exp -> STRING .)
    FOR             reduce using rule 63 (exp -> STRING .)
    IF              reduce using rule 63 (exp -> STRING .)
    REPEAT          reduce using rule 63 (exp -> STRING .)
    WHILE           reduce using rule 63 (exp -> STRING .)
    (               reduce using rule 63 (exp -> STRING .)
    NAME            reduce using rule 63 (exp -> STRING .)
    ]               reduce using rule 63 (exp -> STRING .)


state 43

    (64) exp -> NUMBER .
    THEN            reduce using rule 64 (exp -> NUMBER .)
    OR              reduce using rule 64 (exp -> NUMBER .)
    AND             reduce using rule 64 (exp -> NUMBER .)
    NE              reduce using rule 64 (exp -> NUMBER .)
    EQ              reduce using rule 64 (exp -> NUMBER .)
    GE              reduce using rule 64 (exp -> NUMBER .)
    GT              reduce using rule 64 (exp -> NUMBER .)
    LE              reduce using rule 64 (exp -> NUMBER .)
    LT              reduce using rule 64 (exp -> NUMBER .)
    CONCAT          reduce using rule 64 (exp -> NUMBER .)
    %               reduce using rule 64 (exp -> NUMBER .)
    ^               reduce using rule 64 (exp -> NUMBER .)
    /               reduce using rule 64 (exp -> NUMBER .)
    *               reduce using rule 64 (exp -> NUMBER .)
    -               reduce using rule 64 (exp -> NUMBER .)
    +               reduce using rule 64 (exp -> NUMBER .)
    DO              reduce using rule 64 (exp -> NUMBER .)
    )               reduce using rule 64 (exp -> NUMBER .)
    ,               reduce using rule 64 (exp -> NUMBER .)
    ;               reduce using rule 64 (exp -> NUMBER .)
    $end            reduce using rule 64 (exp -> NUMBER .)
    END             reduce using rule 64 (exp -> NUMBER .)
    UNTIL           reduce using rule 64 (exp -> NUMBER .)
    ELSEIF          reduce using rule 64 (exp -> NUMBER .)
    ELSE            reduce using rule 64 (exp -> NUMBER .)
    }               reduce using rule 64 (exp -> NUMBER .)
    BREAK           reduce using rule 64 (exp -> NUMBER .)
    RETURN          reduce using rule 64 (exp -> NUMBER .)
    LOCAL           reduce using rule 64 (exp -> NUMBER .)
    FUNCTION        reduce using rule 64 (exp -> NUMBER .)
    FOR             reduce using rule 64 (exp -> NUMBER .)
    IF              reduce using rule 64 (exp -> NUMBER .)
    REPEAT          reduce using rule 64 (exp -> NUMBER .)
    WHILE           reduce using rule 64 (exp -> NUMBER .)
    (               reduce using rule 64 (exp -> NUMBER .)
    NAME            reduce using rule 64 (exp -> NUMBER .)
    ]               reduce using rule 64 (exp -> NUMBER .)


state 44

    (65) exp -> TRUE .
    THEN            reduce using rule 65 (exp -> TRUE .)
    OR              reduce using rule 65 (exp -> TRUE .)
    AND             reduce using rule 65 (exp -> TRUE .)
    NE              reduce using rule 65 (exp -> TRUE .)
    EQ              reduce using rule 65 (exp -> TRUE .)
    GE              reduce using rule 65 (exp -> TRUE .)
    GT              reduce using rule 65 (exp -> TRUE .)
    LE              reduce using rule 65 (exp -> TRUE .)
    LT              reduce using rule 65 (exp -> TRUE .)
    CONCAT          reduce using rule 65 (exp -> TRUE .)
    %               reduce using rule 65 (exp -> TRUE .)
    ^               reduce using rule 65 (exp -> TRUE .)
    /               reduce using rule 65 (exp -> TRUE .)
    *               reduce using rule 65 (exp -> TRUE .)
    -               reduce using rule 65 (exp -> TRUE .)
    +               reduce using rule 65 (exp -> TRUE .)
    DO              reduce using rule 65 (exp -> TRUE .)
    )               reduce using rule 65 (exp -> TRUE .)
    ,               reduce using rule 65 (exp -> TRUE .)
    ;               reduce using rule 65 (exp -> TRUE .)
    $end            reduce using rule 65 (exp -> TRUE .)
    END             reduce using rule 65 (exp -> TRUE .)
    UNTIL           reduce using rule 65 (exp -> TRUE .)
    ELSEIF          reduce using rule 65 (exp -> TRUE .)
    ELSE            reduce using rule 65 (exp -> TRUE .)
    }               reduce using rule 65 (exp -> TRUE .)
    BREAK           reduce using rule 65 (exp -> TRUE .)
    RETURN          reduce using rule 65 (exp -> TRUE .)
    LOCAL           reduce using rule 65 (exp -> TRUE .)
    FUNCTION        reduce using rule 65 (exp -> TRUE .)
    FOR             reduce using rule 65 (exp -> TRUE .)
    IF              reduce using rule 65 (exp -> TRUE .)
    REPEAT          reduce using rule 65 (exp -> TRUE .)
    WHILE           reduce using rule 65 (exp -> TRUE .)
    (               reduce using rule 65 (exp -> TRUE .)
    NAME            reduce using rule 65 (exp -> TRUE .)
    ]               reduce using rule 65 (exp -> TRUE .)


state 45

    (66) exp -> FALSE .
    THEN            reduce using rule 66 (exp -> FALSE .)
    OR              reduce using rule 66 (exp -> FALSE .)
    AND             reduce using rule 66 (exp -> FALSE .)
    NE              reduce using rule 66 (exp -> FALSE .)
    EQ              reduce using rule 66 (exp -> FALSE .)
    GE              reduce using rule 66 (exp -> FALSE .)
    GT              reduce using rule 66 (exp -> FALSE .)
    LE              reduce using rule 66 (exp -> FALSE .)
    LT              reduce using rule 66 (exp -> FALSE .)
    CONCAT          reduce using rule 66 (exp -> FALSE .)
    %               reduce using rule 66 (exp -> FALSE .)
    ^               reduce using rule 66 (exp -> FALSE .)
    /               reduce using rule 66 (exp -> FALSE .)
    *               reduce using rule 66 (exp -> FALSE .)
    -               reduce using rule 66 (exp -> FALSE .)
    +               reduce using rule 66 (exp -> FALSE .)
    DO              reduce using rule 66 (exp -> FALSE .)
    )               reduce using rule 66 (exp -> FALSE .)
    ,               reduce using rule 66 (exp -> FALSE .)
    ;               reduce using rule 66 (exp -> FALSE .)
    $end            reduce using rule 66 (exp -> FALSE .)
    END             reduce using rule 66 (exp -> FALSE .)
    UNTIL           reduce using rule 66 (exp -> FALSE .)
    ELSEIF          reduce using rule 66 (exp -> FALSE .)
    ELSE            reduce using rule 66 (exp -> FALSE .)
    }               reduce using rule 66 (exp -> FALSE .)
    BREAK           reduce using rule 66 (exp -> FALSE .)
    RETURN          reduce using rule 66 (exp -> FALSE .)
    LOCAL           reduce using rule 66 (exp -> FALSE .)
    FUNCTION        reduce using rule 66 (exp -> FALSE .)
    FOR             reduce using rule 66 (exp -> FALSE .)
    IF              reduce using rule 66 (exp -> FALSE .)
    REPEAT          reduce using rule 66 (exp -> FALSE .)
    WHILE           reduce using rule 66 (exp -> FALSE .)
    (               reduce using rule 66 (exp -> FALSE .)
    NAME            reduce using rule 66 (exp -> FALSE .)
    ]               reduce using rule 66 (exp -> FALSE .)


state 46

    (67) exp -> NIL .
    THEN            reduce using rule 67 (exp -> NIL .)
    OR              reduce using rule 67 (exp -> NIL .)
    AND             reduce using rule 67 (exp -> NIL .)
    NE              reduce using rule 67 (exp -> NIL .)
    EQ              reduce using rule 67 (exp -> NIL .)
    GE              reduce using rule 67 (exp -> NIL .)
    GT              reduce using rule 67 (exp -> NIL .)
    LE              reduce using rule 67 (exp -> NIL .)
    LT              reduce using rule 67 (exp -> NIL .)
    CONCAT          reduce using rule 67 (exp -> NIL .)
    %               reduce using rule 67 (exp -> NIL .)
    ^               reduce using rule 67 (exp -> NIL .)
    /               reduce using rule 67 (exp -> NIL .)
    *               reduce using rule 67 (exp -> NIL .)
    -               reduce using rule 67 (exp -> NIL .)
    +               reduce using rule 67 (exp -> NIL .)
    DO              reduce using rule 67 (exp -> NIL .)
    )               reduce using rule 67 (exp -> NIL .)
    ,               reduce using rule 67 (exp -> NIL .)
    ;               reduce using rule 67 (exp -> NIL .)
    $end            reduce using rule 67 (exp -> NIL .)
    END             reduce using rule 67 (exp -> NIL .)
    UNTIL           reduce using rule 67 (exp -> NIL .)
    ELSEIF          reduce using rule 67 (exp -> NIL .)
    ELSE            reduce using rule 67 (exp -> NIL .)
    }               reduce using rule 67 (exp -> NIL .)
    BREAK           reduce using rule 67 (exp -> NIL .)
    RETURN          reduce using rule 67 (exp -> NIL .)
    LOCAL           reduce using rule 67 (exp -> NIL .)
    FUNCTION        reduce using rule 67 (exp -> NIL .)
    FOR             reduce using rule 67 (exp -> NIL .)
    IF              reduce using rule 67 (exp -> NIL .)
    REPEAT          reduce using rule 67 (exp -> NIL .)
    WHILE           reduce using rule 67 (exp -> NIL .)
    (               reduce using rule 67 (exp -> NIL .)
    NAME            reduce using rule 67 (exp -> NIL .)
    ]               reduce using rule 67 (exp -> NIL .)


state 47

    (83) tableconstructor -> { . }
    (84) tableconstructor -> { . fieldlist }
    (85) fieldlist -> . fieldlist2 optfieldsep
    (86) fieldlist2 -> . fieldlist2 fieldsep field
    (87) fieldlist2 -> . field
    (88) field -> . exp
    (89) field -> . NAME = exp
    (90) field -> . [ exp ] = exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    }               shift and go to state 95
    NAME            shift and go to state 100
    [               shift and go to state 101
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    fieldlist                      shift and go to state 96
    fieldlist2                     shift and go to state 97
    field                          shift and go to state 98
    exp                            shift and go to state 99
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 48

    (77) function -> FUNCTION . funcbody
    (78) funcbody -> . ( ) block END
    (79) funcbody -> . ( parlist ) block END
    (               shift and go to state 70

    funcbody                       shift and go to state 102

state 49

    (15) stat -> REPEAT block . UNTIL exp
    UNTIL           shift and go to state 103


state 50

    (16) stat -> WHILE exp . DO block END
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    DO              shift and go to state 104
    OR              shift and go to state 77
    AND             shift and go to state 78
    NE              shift and go to state 79
    EQ              shift and go to state 80
    GE              shift and go to state 81
    GT              shift and go to state 82
    LE              shift and go to state 83
    LT              shift and go to state 84
    CONCAT          shift and go to state 85
    %               shift and go to state 86
    ^               shift and go to state 87
    /               shift and go to state 88
    *               shift and go to state 89
    -               shift and go to state 90
    +               shift and go to state 91


state 51

    (18) stat -> varlist = . explist
    (40) explist -> . exp
    (41) explist -> . explist , exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    explist                        shift and go to state 105
    exp                            shift and go to state 65
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 52

    (33) varlist -> varlist , . var
    (34) var -> . prefixexp . name
    (35) var -> . prefixexp [ exp ]
    (36) var -> . name
    (68) prefixexp -> . ( exp )
    (69) prefixexp -> . functioncall
    (70) prefixexp -> . var
    (37) name -> . NAME
    (71) functioncall -> . prefixexp : name args
    (72) functioncall -> . prefixexp args
    (               shift and go to state 15
    NAME            shift and go to state 17

    var                            shift and go to state 106
    prefixexp                      shift and go to state 14
    name                           shift and go to state 6
    functioncall                   shift and go to state 16

state 53

    (34) var -> prefixexp . . name
    (37) name -> . NAME
    NAME            shift and go to state 17

    name                           shift and go to state 107

state 54

    (35) var -> prefixexp [ . exp ]
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 108
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 55

    (71) functioncall -> prefixexp : . name args
    (37) name -> . NAME
    NAME            shift and go to state 17

    name                           shift and go to state 109

state 56

    (72) functioncall -> prefixexp args .
    .               reduce using rule 72 (functioncall -> prefixexp args .)
    [               reduce using rule 72 (functioncall -> prefixexp args .)
    :               reduce using rule 72 (functioncall -> prefixexp args .)
    STRING          reduce using rule 72 (functioncall -> prefixexp args .)
    (               reduce using rule 72 (functioncall -> prefixexp args .)
    {               reduce using rule 72 (functioncall -> prefixexp args .)


state 57

    (73) args -> STRING .
    .               reduce using rule 73 (args -> STRING .)
    [               reduce using rule 73 (args -> STRING .)
    :               reduce using rule 73 (args -> STRING .)
    STRING          reduce using rule 73 (args -> STRING .)
    (               reduce using rule 73 (args -> STRING .)
    {               reduce using rule 73 (args -> STRING .)


state 58

    (74) args -> tableconstructor .
    .               reduce using rule 74 (args -> tableconstructor .)
    [               reduce using rule 74 (args -> tableconstructor .)
    :               reduce using rule 74 (args -> tableconstructor .)
    STRING          reduce using rule 74 (args -> tableconstructor .)
    (               reduce using rule 74 (args -> tableconstructor .)
    {               reduce using rule 74 (args -> tableconstructor .)


state 59

    (75) args -> ( . explist )
    (76) args -> ( . )
    (40) explist -> . exp
    (41) explist -> . explist , exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    )               shift and go to state 111
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    explist                        shift and go to state 110
    exp                            shift and go to state 65
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 60

    (68) prefixexp -> ( exp . )
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    )               shift and go to state 112
    OR              shift and go to state 77
    AND             shift and go to state 78
    NE              shift and go to state 79
    EQ              shift and go to state 80
    GE              shift and go to state 81
    GT              shift and go to state 82
    LE              shift and go to state 83
    LT              shift and go to state 84
    CONCAT          shift and go to state 85
    %               shift and go to state 86
    ^               shift and go to state 87
    /               shift and go to state 88
    *               shift and go to state 89
    -               shift and go to state 90
    +               shift and go to state 91


state 61

    (2) chunk2 -> chunk2 stat optsemi .
    BREAK           reduce using rule 2 (chunk2 -> chunk2 stat optsemi .)
    RETURN          reduce using rule 2 (chunk2 -> chunk2 stat optsemi .)
    LOCAL           reduce using rule 2 (chunk2 -> chunk2 stat optsemi .)
    FUNCTION        reduce using rule 2 (chunk2 -> chunk2 stat optsemi .)
    FOR             reduce using rule 2 (chunk2 -> chunk2 stat optsemi .)
    IF              reduce using rule 2 (chunk2 -> chunk2 stat optsemi .)
    REPEAT          reduce using rule 2 (chunk2 -> chunk2 stat optsemi .)
    WHILE           reduce using rule 2 (chunk2 -> chunk2 stat optsemi .)
    DO              reduce using rule 2 (chunk2 -> chunk2 stat optsemi .)
    (               reduce using rule 2 (chunk2 -> chunk2 stat optsemi .)
    NAME            reduce using rule 2 (chunk2 -> chunk2 stat optsemi .)


state 62

    (25) laststat -> BREAK optsemi .
    $end            reduce using rule 25 (laststat -> BREAK optsemi .)
    END             reduce using rule 25 (laststat -> BREAK optsemi .)
    UNTIL           reduce using rule 25 (laststat -> BREAK optsemi .)
    ELSEIF          reduce using rule 25 (laststat -> BREAK optsemi .)
    ELSE            reduce using rule 25 (laststat -> BREAK optsemi .)


state 63

    (26) laststat -> RETURN optsemi .
    $end            reduce using rule 26 (laststat -> RETURN optsemi .)
    END             reduce using rule 26 (laststat -> RETURN optsemi .)
    UNTIL           reduce using rule 26 (laststat -> RETURN optsemi .)
    ELSEIF          reduce using rule 26 (laststat -> RETURN optsemi .)
    ELSE            reduce using rule 26 (laststat -> RETURN optsemi .)


state 64

    (27) laststat -> RETURN explist . optsemi
    (41) explist -> explist . , exp
    (5) optsemi -> . empty
    (6) optsemi -> . ;
    (95) empty -> .
    ,               shift and go to state 114
    ;               shift and go to state 24
    $end            reduce using rule 95 (empty -> .)
    END             reduce using rule 95 (empty -> .)
    UNTIL           reduce using rule 95 (empty -> .)
    ELSEIF          reduce using rule 95 (empty -> .)
    ELSE            reduce using rule 95 (empty -> .)

    optsemi                        shift and go to state 113
    empty                          shift and go to state 23

state 65

    (40) explist -> exp .
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    ,               reduce using rule 40 (explist -> exp .)
    ;               reduce using rule 40 (explist -> exp .)
    $end            reduce using rule 40 (explist -> exp .)
    END             reduce using rule 40 (explist -> exp .)
    UNTIL           reduce using rule 40 (explist -> exp .)
    ELSEIF          reduce using rule 40 (explist -> exp .)
    ELSE            reduce using rule 40 (explist -> exp .)
    BREAK           reduce using rule 40 (explist -> exp .)
    RETURN          reduce using rule 40 (explist -> exp .)
    LOCAL           reduce using rule 40 (explist -> exp .)
    FUNCTION        reduce using rule 40 (explist -> exp .)
    FOR             reduce using rule 40 (explist -> exp .)
    IF              reduce using rule 40 (explist -> exp .)
    REPEAT          reduce using rule 40 (explist -> exp .)
    WHILE           reduce using rule 40 (explist -> exp .)
    DO              reduce using rule 40 (explist -> exp .)
    (               reduce using rule 40 (explist -> exp .)
    NAME            reduce using rule 40 (explist -> exp .)
    )               reduce using rule 40 (explist -> exp .)
    OR              shift and go to state 77
    AND             shift and go to state 78
    NE              shift and go to state 79
    EQ              shift and go to state 80
    GE              shift and go to state 81
    GT              shift and go to state 82
    LE              shift and go to state 83
    LT              shift and go to state 84
    CONCAT          shift and go to state 85
    %               shift and go to state 86
    ^               shift and go to state 87
    /               shift and go to state 88
    *               shift and go to state 89
    -               shift and go to state 90
    +               shift and go to state 91


state 66

    (7) stat -> LOCAL namelist = . explist
    (40) explist -> . exp
    (41) explist -> . explist , exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    explist                        shift and go to state 115
    exp                            shift and go to state 65
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 67

    (39) namelist -> namelist , . name
    (37) name -> . NAME
    NAME            shift and go to state 17

    name                           shift and go to state 116

state 68

    (9) stat -> LOCAL FUNCTION name . funcbody
    (78) funcbody -> . ( ) block END
    (79) funcbody -> . ( parlist ) block END
    (               shift and go to state 70

    funcbody                       shift and go to state 117

state 69

    (10) stat -> FUNCTION funcname funcbody .
    ;               reduce using rule 10 (stat -> FUNCTION funcname funcbody .)
    BREAK           reduce using rule 10 (stat -> FUNCTION funcname funcbody .)
    RETURN          reduce using rule 10 (stat -> FUNCTION funcname funcbody .)
    LOCAL           reduce using rule 10 (stat -> FUNCTION funcname funcbody .)
    FUNCTION        reduce using rule 10 (stat -> FUNCTION funcname funcbody .)
    FOR             reduce using rule 10 (stat -> FUNCTION funcname funcbody .)
    IF              reduce using rule 10 (stat -> FUNCTION funcname funcbody .)
    REPEAT          reduce using rule 10 (stat -> FUNCTION funcname funcbody .)
    WHILE           reduce using rule 10 (stat -> FUNCTION funcname funcbody .)
    DO              reduce using rule 10 (stat -> FUNCTION funcname funcbody .)
    (               reduce using rule 10 (stat -> FUNCTION funcname funcbody .)
    NAME            reduce using rule 10 (stat -> FUNCTION funcname funcbody .)


state 70

    (78) funcbody -> ( . ) block END
    (79) funcbody -> ( . parlist ) block END
    (80) parlist -> . VARARG
    (81) parlist -> . namelist , VARARG
    (82) parlist -> . namelist
    (38) namelist -> . name
    (39) namelist -> . namelist , name
    (37) name -> . NAME
    )               shift and go to state 118
    VARARG          shift and go to state 120
    NAME            shift and go to state 17

    parlist                        shift and go to state 119
    namelist                       shift and go to state 121
    name                           shift and go to state 27

state 71

    (29) funcname -> funcname2 : . name
    (37) name -> . NAME
    NAME            shift and go to state 17

    name                           shift and go to state 122

state 72

    (30) funcname2 -> funcname2 . . name
    (37) name -> . NAME
    NAME            shift and go to state 17

    name                           shift and go to state 123

state 73

    (11) stat -> FOR namelist IN . explist DO block END
    (40) explist -> . exp
    (41) explist -> . explist , exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    explist                        shift and go to state 124
    exp                            shift and go to state 65
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 74

    (12) stat -> FOR name = . exp , exp , exp DO block END
    (13) stat -> FOR name = . exp , exp DO block END
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 125
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 75

    (17) stat -> DO block END .
    ;               reduce using rule 17 (stat -> DO block END .)
    BREAK           reduce using rule 17 (stat -> DO block END .)
    RETURN          reduce using rule 17 (stat -> DO block END .)
    LOCAL           reduce using rule 17 (stat -> DO block END .)
    FUNCTION        reduce using rule 17 (stat -> DO block END .)
    FOR             reduce using rule 17 (stat -> DO block END .)
    IF              reduce using rule 17 (stat -> DO block END .)
    REPEAT          reduce using rule 17 (stat -> DO block END .)
    WHILE           reduce using rule 17 (stat -> DO block END .)
    DO              reduce using rule 17 (stat -> DO block END .)
    (               reduce using rule 17 (stat -> DO block END .)
    NAME            reduce using rule 17 (stat -> DO block END .)


state 76

    (14) stat -> IF exp THEN . block elseiflist _else END
    (4) block -> . chunk
    (1) chunk -> . chunk2 laststat
    (2) chunk2 -> . chunk2 stat optsemi
    (3) chunk2 -> . stat optsemi
    (7) stat -> . LOCAL namelist = explist
    (8) stat -> . LOCAL namelist
    (9) stat -> . LOCAL FUNCTION name funcbody
    (10) stat -> . FUNCTION funcname funcbody
    (11) stat -> . FOR namelist IN explist DO block END
    (12) stat -> . FOR name = exp , exp , exp DO block END
    (13) stat -> . FOR name = exp , exp DO block END
    (14) stat -> . IF exp THEN block elseiflist _else END
    (15) stat -> . REPEAT block UNTIL exp
    (16) stat -> . WHILE exp DO block END
    (17) stat -> . DO block END
    (18) stat -> . varlist = explist
    (32) varlist -> . var
    (33) varlist -> . varlist , var
    (34) var -> . prefixexp . name
    (35) var -> . prefixexp [ exp ]
    (36) var -> . name
    (68) prefixexp -> . ( exp )
    (69) prefixexp -> . functioncall
    (70) prefixexp -> . var
    (37) name -> . NAME
    (71) functioncall -> . prefixexp : name args
    (72) functioncall -> . prefixexp args
    LOCAL           shift and go to state 4
    FUNCTION        shift and go to state 5
    FOR             shift and go to state 7
    IF              shift and go to state 9
    REPEAT          shift and go to state 10
    WHILE           shift and go to state 11
    DO              shift and go to state 8
    (               shift and go to state 15
    NAME            shift and go to state 17

    block                          shift and go to state 126
    chunk                          shift and go to state 34
    chunk2                         shift and go to state 2
    stat                           shift and go to state 3
    name                           shift and go to state 6
    varlist                        shift and go to state 12
    var                            shift and go to state 13
    prefixexp                      shift and go to state 14
    functioncall                   shift and go to state 16

state 77

    (45) exp -> exp OR . exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 127
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 78

    (46) exp -> exp AND . exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 128
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 79

    (47) exp -> exp NE . exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 129
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 80

    (48) exp -> exp EQ . exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 130
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 81

    (49) exp -> exp GE . exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 131
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 82

    (50) exp -> exp GT . exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 132
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 83

    (51) exp -> exp LE . exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 133
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 84

    (52) exp -> exp LT . exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 134
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 85

    (53) exp -> exp CONCAT . exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 135
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 86

    (54) exp -> exp % . exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 136
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 87

    (55) exp -> exp ^ . exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 137
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 88

    (56) exp -> exp / . exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 138
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 89

    (57) exp -> exp * . exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 139
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 90

    (58) exp -> exp - . exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 140
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 91

    (59) exp -> exp + . exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 141
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 92

    (42) exp -> # exp .
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    THEN            reduce using rule 42 (exp -> # exp .)
    OR              reduce using rule 42 (exp -> # exp .)
    AND             reduce using rule 42 (exp -> # exp .)
    NE              reduce using rule 42 (exp -> # exp .)
    EQ              reduce using rule 42 (exp -> # exp .)
    GE              reduce using rule 42 (exp -> # exp .)
    GT              reduce using rule 42 (exp -> # exp .)
    LE              reduce using rule 42 (exp -> # exp .)
    LT              reduce using rule 42 (exp -> # exp .)
    CONCAT          reduce using rule 42 (exp -> # exp .)
    %               reduce using rule 42 (exp -> # exp .)
    /               reduce using rule 42 (exp -> # exp .)
    *               reduce using rule 42 (exp -> # exp .)
    -               reduce using rule 42 (exp -> # exp .)
    +               reduce using rule 42 (exp -> # exp .)
    DO              reduce using rule 42 (exp -> # exp .)
    )               reduce using rule 42 (exp -> # exp .)
    ,               reduce using rule 42 (exp -> # exp .)
    ;               reduce using rule 42 (exp -> # exp .)
    $end            reduce using rule 42 (exp -> # exp .)
    END             reduce using rule 42 (exp -> # exp .)
    UNTIL           reduce using rule 42 (exp -> # exp .)
    ELSEIF          reduce using rule 42 (exp -> # exp .)
    ELSE            reduce using rule 42 (exp -> # exp .)
    }               reduce using rule 42 (exp -> # exp .)
    BREAK           reduce using rule 42 (exp -> # exp .)
    RETURN          reduce using rule 42 (exp -> # exp .)
    LOCAL           reduce using rule 42 (exp -> # exp .)
    FUNCTION        reduce using rule 42 (exp -> # exp .)
    FOR             reduce using rule 42 (exp -> # exp .)
    IF              reduce using rule 42 (exp -> # exp .)
    REPEAT          reduce using rule 42 (exp -> # exp .)
    WHILE           reduce using rule 42 (exp -> # exp .)
    (               reduce using rule 42 (exp -> # exp .)
    NAME            reduce using rule 42 (exp -> # exp .)
    ]               reduce using rule 42 (exp -> # exp .)
    ^               shift and go to state 87


state 93

    (43) exp -> NOT exp .
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    THEN            reduce using rule 43 (exp -> NOT exp .)
    OR              reduce using rule 43 (exp -> NOT exp .)
    AND             reduce using rule 43 (exp -> NOT exp .)
    NE              reduce using rule 43 (exp -> NOT exp .)
    EQ              reduce using rule 43 (exp -> NOT exp .)
    GE              reduce using rule 43 (exp -> NOT exp .)
    GT              reduce using rule 43 (exp -> NOT exp .)
    LE              reduce using rule 43 (exp -> NOT exp .)
    LT              reduce using rule 43 (exp -> NOT exp .)
    CONCAT          reduce using rule 43 (exp -> NOT exp .)
    %               reduce using rule 43 (exp -> NOT exp .)
    /               reduce using rule 43 (exp -> NOT exp .)
    *               reduce using rule 43 (exp -> NOT exp .)
    -               reduce using rule 43 (exp -> NOT exp .)
    +               reduce using rule 43 (exp -> NOT exp .)
    DO              reduce using rule 43 (exp -> NOT exp .)
    )               reduce using rule 43 (exp -> NOT exp .)
    ,               reduce using rule 43 (exp -> NOT exp .)
    ;               reduce using rule 43 (exp -> NOT exp .)
    $end            reduce using rule 43 (exp -> NOT exp .)
    END             reduce using rule 43 (exp -> NOT exp .)
    UNTIL           reduce using rule 43 (exp -> NOT exp .)
    ELSEIF          reduce using rule 43 (exp -> NOT exp .)
    ELSE            reduce using rule 43 (exp -> NOT exp .)
    }               reduce using rule 43 (exp -> NOT exp .)
    BREAK           reduce using rule 43 (exp -> NOT exp .)
    RETURN          reduce using rule 43 (exp -> NOT exp .)
    LOCAL           reduce using rule 43 (exp -> NOT exp .)
    FUNCTION        reduce using rule 43 (exp -> NOT exp .)
    FOR             reduce using rule 43 (exp -> NOT exp .)
    IF              reduce using rule 43 (exp -> NOT exp .)
    REPEAT          reduce using rule 43 (exp -> NOT exp .)
    WHILE           reduce using rule 43 (exp -> NOT exp .)
    (               reduce using rule 43 (exp -> NOT exp .)
    NAME            reduce using rule 43 (exp -> NOT exp .)
    ]               reduce using rule 43 (exp -> NOT exp .)
    ^               shift and go to state 87


state 94

    (44) exp -> - exp .
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    THEN            reduce using rule 44 (exp -> - exp .)
    OR              reduce using rule 44 (exp -> - exp .)
    AND             reduce using rule 44 (exp -> - exp .)
    NE              reduce using rule 44 (exp -> - exp .)
    EQ              reduce using rule 44 (exp -> - exp .)
    GE              reduce using rule 44 (exp -> - exp .)
    GT              reduce using rule 44 (exp -> - exp .)
    LE              reduce using rule 44 (exp -> - exp .)
    LT              reduce using rule 44 (exp -> - exp .)
    CONCAT          reduce using rule 44 (exp -> - exp .)
    %               reduce using rule 44 (exp -> - exp .)
    /               reduce using rule 44 (exp -> - exp .)
    *               reduce using rule 44 (exp -> - exp .)
    -               reduce using rule 44 (exp -> - exp .)
    +               reduce using rule 44 (exp -> - exp .)
    DO              reduce using rule 44 (exp -> - exp .)
    )               reduce using rule 44 (exp -> - exp .)
    ,               reduce using rule 44 (exp -> - exp .)
    ;               reduce using rule 44 (exp -> - exp .)
    $end            reduce using rule 44 (exp -> - exp .)
    END             reduce using rule 44 (exp -> - exp .)
    UNTIL           reduce using rule 44 (exp -> - exp .)
    ELSEIF          reduce using rule 44 (exp -> - exp .)
    ELSE            reduce using rule 44 (exp -> - exp .)
    }               reduce using rule 44 (exp -> - exp .)
    BREAK           reduce using rule 44 (exp -> - exp .)
    RETURN          reduce using rule 44 (exp -> - exp .)
    LOCAL           reduce using rule 44 (exp -> - exp .)
    FUNCTION        reduce using rule 44 (exp -> - exp .)
    FOR             reduce using rule 44 (exp -> - exp .)
    IF              reduce using rule 44 (exp -> - exp .)
    REPEAT          reduce using rule 44 (exp -> - exp .)
    WHILE           reduce using rule 44 (exp -> - exp .)
    (               reduce using rule 44 (exp -> - exp .)
    NAME            reduce using rule 44 (exp -> - exp .)
    ]               reduce using rule 44 (exp -> - exp .)
    ^               shift and go to state 87


state 95

    (83) tableconstructor -> { } .
    THEN            reduce using rule 83 (tableconstructor -> { } .)
    OR              reduce using rule 83 (tableconstructor -> { } .)
    AND             reduce using rule 83 (tableconstructor -> { } .)
    NE              reduce using rule 83 (tableconstructor -> { } .)
    EQ              reduce using rule 83 (tableconstructor -> { } .)
    GE              reduce using rule 83 (tableconstructor -> { } .)
    GT              reduce using rule 83 (tableconstructor -> { } .)
    LE              reduce using rule 83 (tableconstructor -> { } .)
    LT              reduce using rule 83 (tableconstructor -> { } .)
    CONCAT          reduce using rule 83 (tableconstructor -> { } .)
    %               reduce using rule 83 (tableconstructor -> { } .)
    ^               reduce using rule 83 (tableconstructor -> { } .)
    /               reduce using rule 83 (tableconstructor -> { } .)
    *               reduce using rule 83 (tableconstructor -> { } .)
    -               reduce using rule 83 (tableconstructor -> { } .)
    +               reduce using rule 83 (tableconstructor -> { } .)
    DO              reduce using rule 83 (tableconstructor -> { } .)
    .               reduce using rule 83 (tableconstructor -> { } .)
    [               reduce using rule 83 (tableconstructor -> { } .)
    :               reduce using rule 83 (tableconstructor -> { } .)
    STRING          reduce using rule 83 (tableconstructor -> { } .)
    (               reduce using rule 83 (tableconstructor -> { } .)
    {               reduce using rule 83 (tableconstructor -> { } .)
    )               reduce using rule 83 (tableconstructor -> { } .)
    ,               reduce using rule 83 (tableconstructor -> { } .)
    ;               reduce using rule 83 (tableconstructor -> { } .)
    $end            reduce using rule 83 (tableconstructor -> { } .)
    END             reduce using rule 83 (tableconstructor -> { } .)
    UNTIL           reduce using rule 83 (tableconstructor -> { } .)
    ELSEIF          reduce using rule 83 (tableconstructor -> { } .)
    ELSE            reduce using rule 83 (tableconstructor -> { } .)
    }               reduce using rule 83 (tableconstructor -> { } .)
    BREAK           reduce using rule 83 (tableconstructor -> { } .)
    RETURN          reduce using rule 83 (tableconstructor -> { } .)
    LOCAL           reduce using rule 83 (tableconstructor -> { } .)
    FUNCTION        reduce using rule 83 (tableconstructor -> { } .)
    FOR             reduce using rule 83 (tableconstructor -> { } .)
    IF              reduce using rule 83 (tableconstructor -> { } .)
    REPEAT          reduce using rule 83 (tableconstructor -> { } .)
    WHILE           reduce using rule 83 (tableconstructor -> { } .)
    NAME            reduce using rule 83 (tableconstructor -> { } .)
    ]               reduce using rule 83 (tableconstructor -> { } .)


state 96

    (84) tableconstructor -> { fieldlist . }
    }               shift and go to state 142


state 97

    (85) fieldlist -> fieldlist2 . optfieldsep
    (86) fieldlist2 -> fieldlist2 . fieldsep field
    (91) optfieldsep -> . empty
    (92) optfieldsep -> . fieldsep
    (93) fieldsep -> . ;
    (94) fieldsep -> . ,
    (95) empty -> .
    ;               shift and go to state 146
    ,               shift and go to state 147
    }               reduce using rule 95 (empty -> .)

    optfieldsep                    shift and go to state 143
    fieldsep                       shift and go to state 144
    empty                          shift and go to state 145

state 98

    (87) fieldlist2 -> field .
    ;               reduce using rule 87 (fieldlist2 -> field .)
    ,               reduce using rule 87 (fieldlist2 -> field .)
    }               reduce using rule 87 (fieldlist2 -> field .)


state 99

    (88) field -> exp .
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    ;               reduce using rule 88 (field -> exp .)
    ,               reduce using rule 88 (field -> exp .)
    }               reduce using rule 88 (field -> exp .)
    OR              shift and go to state 77
    AND             shift and go to state 78
    NE              shift and go to state 79
    EQ              shift and go to state 80
    GE              shift and go to state 81
    GT              shift and go to state 82
    LE              shift and go to state 83
    LT              shift and go to state 84
    CONCAT          shift and go to state 85
    %               shift and go to state 86
    ^               shift and go to state 87
    /               shift and go to state 88
    *               shift and go to state 89
    -               shift and go to state 90
    +               shift and go to state 91


state 100

    (89) field -> NAME . = exp
    =               shift and go to state 148


state 101

    (90) field -> [ . exp ] = exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 149
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 102

    (77) function -> FUNCTION funcbody .
    THEN            reduce using rule 77 (function -> FUNCTION funcbody .)
    OR              reduce using rule 77 (function -> FUNCTION funcbody .)
    AND             reduce using rule 77 (function -> FUNCTION funcbody .)
    NE              reduce using rule 77 (function -> FUNCTION funcbody .)
    EQ              reduce using rule 77 (function -> FUNCTION funcbody .)
    GE              reduce using rule 77 (function -> FUNCTION funcbody .)
    GT              reduce using rule 77 (function -> FUNCTION funcbody .)
    LE              reduce using rule 77 (function -> FUNCTION funcbody .)
    LT              reduce using rule 77 (function -> FUNCTION funcbody .)
    CONCAT          reduce using rule 77 (function -> FUNCTION funcbody .)
    %               reduce using rule 77 (function -> FUNCTION funcbody .)
    ^               reduce using rule 77 (function -> FUNCTION funcbody .)
    /               reduce using rule 77 (function -> FUNCTION funcbody .)
    *               reduce using rule 77 (function -> FUNCTION funcbody .)
    -               reduce using rule 77 (function -> FUNCTION funcbody .)
    +               reduce using rule 77 (function -> FUNCTION funcbody .)
    DO              reduce using rule 77 (function -> FUNCTION funcbody .)
    )               reduce using rule 77 (function -> FUNCTION funcbody .)
    ,               reduce using rule 77 (function -> FUNCTION funcbody .)
    ;               reduce using rule 77 (function -> FUNCTION funcbody .)
    $end            reduce using rule 77 (function -> FUNCTION funcbody .)
    END             reduce using rule 77 (function -> FUNCTION funcbody .)
    UNTIL           reduce using rule 77 (function -> FUNCTION funcbody .)
    ELSEIF          reduce using rule 77 (function -> FUNCTION funcbody .)
    ELSE            reduce using rule 77 (function -> FUNCTION funcbody .)
    }               reduce using rule 77 (function -> FUNCTION funcbody .)
    BREAK           reduce using rule 77 (function -> FUNCTION funcbody .)
    RETURN          reduce using rule 77 (function -> FUNCTION funcbody .)
    LOCAL           reduce using rule 77 (function -> FUNCTION funcbody .)
    FUNCTION        reduce using rule 77 (function -> FUNCTION funcbody .)
    FOR             reduce using rule 77 (function -> FUNCTION funcbody .)
    IF              reduce using rule 77 (function -> FUNCTION funcbody .)
    REPEAT          reduce using rule 77 (function -> FUNCTION funcbody .)
    WHILE           reduce using rule 77 (function -> FUNCTION funcbody .)
    (               reduce using rule 77 (function -> FUNCTION funcbody .)
    NAME            reduce using rule 77 (function -> FUNCTION funcbody .)
    ]               reduce using rule 77 (function -> FUNCTION funcbody .)


state 103

    (15) stat -> REPEAT block UNTIL . exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 150
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 104

    (16) stat -> WHILE exp DO . block END
    (4) block -> . chunk
    (1) chunk -> . chunk2 laststat
    (2) chunk2 -> . chunk2 stat optsemi
    (3) chunk2 -> . stat optsemi
    (7) stat -> . LOCAL namelist = explist
    (8) stat -> . LOCAL namelist
    (9) stat -> . LOCAL FUNCTION name funcbody
    (10) stat -> . FUNCTION funcname funcbody
    (11) stat -> . FOR namelist IN explist DO block END
    (12) stat -> . FOR name = exp , exp , exp DO block END
    (13) stat -> . FOR name = exp , exp DO block END
    (14) stat -> . IF exp THEN block elseiflist _else END
    (15) stat -> . REPEAT block UNTIL exp
    (16) stat -> . WHILE exp DO block END
    (17) stat -> . DO block END
    (18) stat -> . varlist = explist
    (32) varlist -> . var
    (33) varlist -> . varlist , var
    (34) var -> . prefixexp . name
    (35) var -> . prefixexp [ exp ]
    (36) var -> . name
    (68) prefixexp -> . ( exp )
    (69) prefixexp -> . functioncall
    (70) prefixexp -> . var
    (37) name -> . NAME
    (71) functioncall -> . prefixexp : name args
    (72) functioncall -> . prefixexp args
    LOCAL           shift and go to state 4
    FUNCTION        shift and go to state 5
    FOR             shift and go to state 7
    IF              shift and go to state 9
    REPEAT          shift and go to state 10
    WHILE           shift and go to state 11
    DO              shift and go to state 8
    (               shift and go to state 15
    NAME            shift and go to state 17

    block                          shift and go to state 151
    chunk                          shift and go to state 34
    chunk2                         shift and go to state 2
    stat                           shift and go to state 3
    name                           shift and go to state 6
    varlist                        shift and go to state 12
    var                            shift and go to state 13
    prefixexp                      shift and go to state 14
    functioncall                   shift and go to state 16

state 105

    (18) stat -> varlist = explist .
    (41) explist -> explist . , exp
    ;               reduce using rule 18 (stat -> varlist = explist .)
    BREAK           reduce using rule 18 (stat -> varlist = explist .)
    RETURN          reduce using rule 18 (stat -> varlist = explist .)
    LOCAL           reduce using rule 18 (stat -> varlist = explist .)
    FUNCTION        reduce using rule 18 (stat -> varlist = explist .)
    FOR             reduce using rule 18 (stat -> varlist = explist .)
    IF              reduce using rule 18 (stat -> varlist = explist .)
    REPEAT          reduce using rule 18 (stat -> varlist = explist .)
    WHILE           reduce using rule 18 (stat -> varlist = explist .)
    DO              reduce using rule 18 (stat -> varlist = explist .)
    (               reduce using rule 18 (stat -> varlist = explist .)
    NAME            reduce using rule 18 (stat -> varlist = explist .)
    ,               shift and go to state 114


state 106

    (33) varlist -> varlist , var .
    (70) prefixexp -> var .
    =               reduce using rule 33 (varlist -> varlist , var .)
    ,               reduce using rule 33 (varlist -> varlist , var .)
    .               reduce using rule 70 (prefixexp -> var .)
    [               reduce using rule 70 (prefixexp -> var .)
    :               reduce using rule 70 (prefixexp -> var .)
    STRING          reduce using rule 70 (prefixexp -> var .)
    (               reduce using rule 70 (prefixexp -> var .)
    {               reduce using rule 70 (prefixexp -> var .)


state 107

    (34) var -> prefixexp . name .
    =               reduce using rule 34 (var -> prefixexp . name .)
    ,               reduce using rule 34 (var -> prefixexp . name .)
    .               reduce using rule 34 (var -> prefixexp . name .)
    [               reduce using rule 34 (var -> prefixexp . name .)
    :               reduce using rule 34 (var -> prefixexp . name .)
    STRING          reduce using rule 34 (var -> prefixexp . name .)
    (               reduce using rule 34 (var -> prefixexp . name .)
    {               reduce using rule 34 (var -> prefixexp . name .)


state 108

    (35) var -> prefixexp [ exp . ]
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    ]               shift and go to state 152
    OR              shift and go to state 77
    AND             shift and go to state 78
    NE              shift and go to state 79
    EQ              shift and go to state 80
    GE              shift and go to state 81
    GT              shift and go to state 82
    LE              shift and go to state 83
    LT              shift and go to state 84
    CONCAT          shift and go to state 85
    %               shift and go to state 86
    ^               shift and go to state 87
    /               shift and go to state 88
    *               shift and go to state 89
    -               shift and go to state 90
    +               shift and go to state 91


state 109

    (71) functioncall -> prefixexp : name . args
    (73) args -> . STRING
    (74) args -> . tableconstructor
    (75) args -> . ( explist )
    (76) args -> . ( )
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    STRING          shift and go to state 57
    (               shift and go to state 59
    {               shift and go to state 47

    args                           shift and go to state 153
    tableconstructor               shift and go to state 58

state 110

    (75) args -> ( explist . )
    (41) explist -> explist . , exp
    )               shift and go to state 154
    ,               shift and go to state 114


state 111

    (76) args -> ( ) .
    .               reduce using rule 76 (args -> ( ) .)
    [               reduce using rule 76 (args -> ( ) .)
    :               reduce using rule 76 (args -> ( ) .)
    STRING          reduce using rule 76 (args -> ( ) .)
    (               reduce using rule 76 (args -> ( ) .)
    {               reduce using rule 76 (args -> ( ) .)


state 112

    (68) prefixexp -> ( exp ) .
    .               reduce using rule 68 (prefixexp -> ( exp ) .)
    [               reduce using rule 68 (prefixexp -> ( exp ) .)
    :               reduce using rule 68 (prefixexp -> ( exp ) .)
    STRING          reduce using rule 68 (prefixexp -> ( exp ) .)
    (               reduce using rule 68 (prefixexp -> ( exp ) .)
    {               reduce using rule 68 (prefixexp -> ( exp ) .)


state 113

    (27) laststat -> RETURN explist optsemi .
    $end            reduce using rule 27 (laststat -> RETURN explist optsemi .)
    END             reduce using rule 27 (laststat -> RETURN explist optsemi .)
    UNTIL           reduce using rule 27 (laststat -> RETURN explist optsemi .)
    ELSEIF          reduce using rule 27 (laststat -> RETURN explist optsemi .)
    ELSE            reduce using rule 27 (laststat -> RETURN explist optsemi .)


state 114

    (41) explist -> explist , . exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 155
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 115

    (7) stat -> LOCAL namelist = explist .
    (41) explist -> explist . , exp
    ;               reduce using rule 7 (stat -> LOCAL namelist = explist .)
    BREAK           reduce using rule 7 (stat -> LOCAL namelist = explist .)
    RETURN          reduce using rule 7 (stat -> LOCAL namelist = explist .)
    LOCAL           reduce using rule 7 (stat -> LOCAL namelist = explist .)
    FUNCTION        reduce using rule 7 (stat -> LOCAL namelist = explist .)
    FOR             reduce using rule 7 (stat -> LOCAL namelist = explist .)
    IF              reduce using rule 7 (stat -> LOCAL namelist = explist .)
    REPEAT          reduce using rule 7 (stat -> LOCAL namelist = explist .)
    WHILE           reduce using rule 7 (stat -> LOCAL namelist = explist .)
    DO              reduce using rule 7 (stat -> LOCAL namelist = explist .)
    (               reduce using rule 7 (stat -> LOCAL namelist = explist .)
    NAME            reduce using rule 7 (stat -> LOCAL namelist = explist .)
    ,               shift and go to state 114


state 116

    (39) namelist -> namelist , name .
    =               reduce using rule 39 (namelist -> namelist , name .)
    ,               reduce using rule 39 (namelist -> namelist , name .)
    ;               reduce using rule 39 (namelist -> namelist , name .)
    BREAK           reduce using rule 39 (namelist -> namelist , name .)
    RETURN          reduce using rule 39 (namelist -> namelist , name .)
    LOCAL           reduce using rule 39 (namelist -> namelist , name .)
    FUNCTION        reduce using rule 39 (namelist -> namelist , name .)
    FOR             reduce using rule 39 (namelist -> namelist , name .)
    IF              reduce using rule 39 (namelist -> namelist , name .)
    REPEAT          reduce using rule 39 (namelist -> namelist , name .)
    WHILE           reduce using rule 39 (namelist -> namelist , name .)
    DO              reduce using rule 39 (namelist -> namelist , name .)
    (               reduce using rule 39 (namelist -> namelist , name .)
    NAME            reduce using rule 39 (namelist -> namelist , name .)
    IN              reduce using rule 39 (namelist -> namelist , name .)
    )               reduce using rule 39 (namelist -> namelist , name .)


state 117

    (9) stat -> LOCAL FUNCTION name funcbody .
    ;               reduce using rule 9 (stat -> LOCAL FUNCTION name funcbody .)
    BREAK           reduce using rule 9 (stat -> LOCAL FUNCTION name funcbody .)
    RETURN          reduce using rule 9 (stat -> LOCAL FUNCTION name funcbody .)
    LOCAL           reduce using rule 9 (stat -> LOCAL FUNCTION name funcbody .)
    FUNCTION        reduce using rule 9 (stat -> LOCAL FUNCTION name funcbody .)
    FOR             reduce using rule 9 (stat -> LOCAL FUNCTION name funcbody .)
    IF              reduce using rule 9 (stat -> LOCAL FUNCTION name funcbody .)
    REPEAT          reduce using rule 9 (stat -> LOCAL FUNCTION name funcbody .)
    WHILE           reduce using rule 9 (stat -> LOCAL FUNCTION name funcbody .)
    DO              reduce using rule 9 (stat -> LOCAL FUNCTION name funcbody .)
    (               reduce using rule 9 (stat -> LOCAL FUNCTION name funcbody .)
    NAME            reduce using rule 9 (stat -> LOCAL FUNCTION name funcbody .)


state 118

    (78) funcbody -> ( ) . block END
    (4) block -> . chunk
    (1) chunk -> . chunk2 laststat
    (2) chunk2 -> . chunk2 stat optsemi
    (3) chunk2 -> . stat optsemi
    (7) stat -> . LOCAL namelist = explist
    (8) stat -> . LOCAL namelist
    (9) stat -> . LOCAL FUNCTION name funcbody
    (10) stat -> . FUNCTION funcname funcbody
    (11) stat -> . FOR namelist IN explist DO block END
    (12) stat -> . FOR name = exp , exp , exp DO block END
    (13) stat -> . FOR name = exp , exp DO block END
    (14) stat -> . IF exp THEN block elseiflist _else END
    (15) stat -> . REPEAT block UNTIL exp
    (16) stat -> . WHILE exp DO block END
    (17) stat -> . DO block END
    (18) stat -> . varlist = explist
    (32) varlist -> . var
    (33) varlist -> . varlist , var
    (34) var -> . prefixexp . name
    (35) var -> . prefixexp [ exp ]
    (36) var -> . name
    (68) prefixexp -> . ( exp )
    (69) prefixexp -> . functioncall
    (70) prefixexp -> . var
    (37) name -> . NAME
    (71) functioncall -> . prefixexp : name args
    (72) functioncall -> . prefixexp args
    LOCAL           shift and go to state 4
    FUNCTION        shift and go to state 5
    FOR             shift and go to state 7
    IF              shift and go to state 9
    REPEAT          shift and go to state 10
    WHILE           shift and go to state 11
    DO              shift and go to state 8
    (               shift and go to state 15
    NAME            shift and go to state 17

    block                          shift and go to state 156
    chunk                          shift and go to state 34
    chunk2                         shift and go to state 2
    stat                           shift and go to state 3
    name                           shift and go to state 6
    varlist                        shift and go to state 12
    var                            shift and go to state 13
    prefixexp                      shift and go to state 14
    functioncall                   shift and go to state 16

state 119

    (79) funcbody -> ( parlist . ) block END
    )               shift and go to state 157


state 120

    (80) parlist -> VARARG .
    )               reduce using rule 80 (parlist -> VARARG .)


state 121

    (81) parlist -> namelist . , VARARG
    (82) parlist -> namelist .
    (39) namelist -> namelist . , name
    ,               shift and go to state 158
    )               reduce using rule 82 (parlist -> namelist .)


state 122

    (29) funcname -> funcname2 : name .
    (               reduce using rule 29 (funcname -> funcname2 : name .)


state 123

    (30) funcname2 -> funcname2 . name .
    :               reduce using rule 30 (funcname2 -> funcname2 . name .)
    .               reduce using rule 30 (funcname2 -> funcname2 . name .)
    (               reduce using rule 30 (funcname2 -> funcname2 . name .)


state 124

    (11) stat -> FOR namelist IN explist . DO block END
    (41) explist -> explist . , exp
    DO              shift and go to state 159
    ,               shift and go to state 114


state 125

    (12) stat -> FOR name = exp . , exp , exp DO block END
    (13) stat -> FOR name = exp . , exp DO block END
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    ,               shift and go to state 160
    OR              shift and go to state 77
    AND             shift and go to state 78
    NE              shift and go to state 79
    EQ              shift and go to state 80
    GE              shift and go to state 81
    GT              shift and go to state 82
    LE              shift and go to state 83
    LT              shift and go to state 84
    CONCAT          shift and go to state 85
    %               shift and go to state 86
    ^               shift and go to state 87
    /               shift and go to state 88
    *               shift and go to state 89
    -               shift and go to state 90
    +               shift and go to state 91


state 126

    (14) stat -> IF exp THEN block . elseiflist _else END
    (19) elseiflist -> . empty
    (20) elseiflist -> . elseiflist elseif
    (21) elseiflist -> . elseif
    (95) empty -> .
    (22) elseif -> . ELSEIF exp THEN block
  ! shift/reduce conflict for ELSEIF resolved as shift
    ELSE            reduce using rule 95 (empty -> .)
    END             reduce using rule 95 (empty -> .)
    ELSEIF          shift and go to state 164

    elseiflist                     shift and go to state 161
    empty                          shift and go to state 162
    elseif                         shift and go to state 163

state 127

    (45) exp -> exp OR exp .
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    THEN            reduce using rule 45 (exp -> exp OR exp .)
    OR              reduce using rule 45 (exp -> exp OR exp .)
    DO              reduce using rule 45 (exp -> exp OR exp .)
    )               reduce using rule 45 (exp -> exp OR exp .)
    ,               reduce using rule 45 (exp -> exp OR exp .)
    ;               reduce using rule 45 (exp -> exp OR exp .)
    $end            reduce using rule 45 (exp -> exp OR exp .)
    END             reduce using rule 45 (exp -> exp OR exp .)
    UNTIL           reduce using rule 45 (exp -> exp OR exp .)
    ELSEIF          reduce using rule 45 (exp -> exp OR exp .)
    ELSE            reduce using rule 45 (exp -> exp OR exp .)
    }               reduce using rule 45 (exp -> exp OR exp .)
    BREAK           reduce using rule 45 (exp -> exp OR exp .)
    RETURN          reduce using rule 45 (exp -> exp OR exp .)
    LOCAL           reduce using rule 45 (exp -> exp OR exp .)
    FUNCTION        reduce using rule 45 (exp -> exp OR exp .)
    FOR             reduce using rule 45 (exp -> exp OR exp .)
    IF              reduce using rule 45 (exp -> exp OR exp .)
    REPEAT          reduce using rule 45 (exp -> exp OR exp .)
    WHILE           reduce using rule 45 (exp -> exp OR exp .)
    (               reduce using rule 45 (exp -> exp OR exp .)
    NAME            reduce using rule 45 (exp -> exp OR exp .)
    ]               reduce using rule 45 (exp -> exp OR exp .)
    AND             shift and go to state 78
    NE              shift and go to state 79
    EQ              shift and go to state 80
    GE              shift and go to state 81
    GT              shift and go to state 82
    LE              shift and go to state 83
    LT              shift and go to state 84
    CONCAT          shift and go to state 85
    %               shift and go to state 86
    ^               shift and go to state 87
    /               shift and go to state 88
    *               shift and go to state 89
    -               shift and go to state 90
    +               shift and go to state 91


state 128

    (46) exp -> exp AND exp .
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    THEN            reduce using rule 46 (exp -> exp AND exp .)
    OR              reduce using rule 46 (exp -> exp AND exp .)
    AND             reduce using rule 46 (exp -> exp AND exp .)
    DO              reduce using rule 46 (exp -> exp AND exp .)
    )               reduce using rule 46 (exp -> exp AND exp .)
    ,               reduce using rule 46 (exp -> exp AND exp .)
    ;               reduce using rule 46 (exp -> exp AND exp .)
    $end            reduce using rule 46 (exp -> exp AND exp .)
    END             reduce using rule 46 (exp -> exp AND exp .)
    UNTIL           reduce using rule 46 (exp -> exp AND exp .)
    ELSEIF          reduce using rule 46 (exp -> exp AND exp .)
    ELSE            reduce using rule 46 (exp -> exp AND exp .)
    }               reduce using rule 46 (exp -> exp AND exp .)
    BREAK           reduce using rule 46 (exp -> exp AND exp .)
    RETURN          reduce using rule 46 (exp -> exp AND exp .)
    LOCAL           reduce using rule 46 (exp -> exp AND exp .)
    FUNCTION        reduce using rule 46 (exp -> exp AND exp .)
    FOR             reduce using rule 46 (exp -> exp AND exp .)
    IF              reduce using rule 46 (exp -> exp AND exp .)
    REPEAT          reduce using rule 46 (exp -> exp AND exp .)
    WHILE           reduce using rule 46 (exp -> exp AND exp .)
    (               reduce using rule 46 (exp -> exp AND exp .)
    NAME            reduce using rule 46 (exp -> exp AND exp .)
    ]               reduce using rule 46 (exp -> exp AND exp .)
    NE              shift and go to state 79
    EQ              shift and go to state 80
    GE              shift and go to state 81
    GT              shift and go to state 82
    LE              shift and go to state 83
    LT              shift and go to state 84
    CONCAT          shift and go to state 85
    %               shift and go to state 86
    ^               shift and go to state 87
    /               shift and go to state 88
    *               shift and go to state 89
    -               shift and go to state 90
    +               shift and go to state 91


state 129

    (47) exp -> exp NE exp .
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    THEN            reduce using rule 47 (exp -> exp NE exp .)
    OR              reduce using rule 47 (exp -> exp NE exp .)
    AND             reduce using rule 47 (exp -> exp NE exp .)
    NE              reduce using rule 47 (exp -> exp NE exp .)
    EQ              reduce using rule 47 (exp -> exp NE exp .)
    GE              reduce using rule 47 (exp -> exp NE exp .)
    GT              reduce using rule 47 (exp -> exp NE exp .)
    LE              reduce using rule 47 (exp -> exp NE exp .)
    LT              reduce using rule 47 (exp -> exp NE exp .)
    DO              reduce using rule 47 (exp -> exp NE exp .)
    )               reduce using rule 47 (exp -> exp NE exp .)
    ,               reduce using rule 47 (exp -> exp NE exp .)
    ;               reduce using rule 47 (exp -> exp NE exp .)
    $end            reduce using rule 47 (exp -> exp NE exp .)
    END             reduce using rule 47 (exp -> exp NE exp .)
    UNTIL           reduce using rule 47 (exp -> exp NE exp .)
    ELSEIF          reduce using rule 47 (exp -> exp NE exp .)
    ELSE            reduce using rule 47 (exp -> exp NE exp .)
    }               reduce using rule 47 (exp -> exp NE exp .)
    BREAK           reduce using rule 47 (exp -> exp NE exp .)
    RETURN          reduce using rule 47 (exp -> exp NE exp .)
    LOCAL           reduce using rule 47 (exp -> exp NE exp .)
    FUNCTION        reduce using rule 47 (exp -> exp NE exp .)
    FOR             reduce using rule 47 (exp -> exp NE exp .)
    IF              reduce using rule 47 (exp -> exp NE exp .)
    REPEAT          reduce using rule 47 (exp -> exp NE exp .)
    WHILE           reduce using rule 47 (exp -> exp NE exp .)
    (               reduce using rule 47 (exp -> exp NE exp .)
    NAME            reduce using rule 47 (exp -> exp NE exp .)
    ]               reduce using rule 47 (exp -> exp NE exp .)
    CONCAT          shift and go to state 85
    %               shift and go to state 86
    ^               shift and go to state 87
    /               shift and go to state 88
    *               shift and go to state 89
    -               shift and go to state 90
    +               shift and go to state 91


state 130

    (48) exp -> exp EQ exp .
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    THEN            reduce using rule 48 (exp -> exp EQ exp .)
    OR              reduce using rule 48 (exp -> exp EQ exp .)
    AND             reduce using rule 48 (exp -> exp EQ exp .)
    NE              reduce using rule 48 (exp -> exp EQ exp .)
    EQ              reduce using rule 48 (exp -> exp EQ exp .)
    GE              reduce using rule 48 (exp -> exp EQ exp .)
    GT              reduce using rule 48 (exp -> exp EQ exp .)
    LE              reduce using rule 48 (exp -> exp EQ exp .)
    LT              reduce using rule 48 (exp -> exp EQ exp .)
    DO              reduce using rule 48 (exp -> exp EQ exp .)
    )               reduce using rule 48 (exp -> exp EQ exp .)
    ,               reduce using rule 48 (exp -> exp EQ exp .)
    ;               reduce using rule 48 (exp -> exp EQ exp .)
    $end            reduce using rule 48 (exp -> exp EQ exp .)
    END             reduce using rule 48 (exp -> exp EQ exp .)
    UNTIL           reduce using rule 48 (exp -> exp EQ exp .)
    ELSEIF          reduce using rule 48 (exp -> exp EQ exp .)
    ELSE            reduce using rule 48 (exp -> exp EQ exp .)
    }               reduce using rule 48 (exp -> exp EQ exp .)
    BREAK           reduce using rule 48 (exp -> exp EQ exp .)
    RETURN          reduce using rule 48 (exp -> exp EQ exp .)
    LOCAL           reduce using rule 48 (exp -> exp EQ exp .)
    FUNCTION        reduce using rule 48 (exp -> exp EQ exp .)
    FOR             reduce using rule 48 (exp -> exp EQ exp .)
    IF              reduce using rule 48 (exp -> exp EQ exp .)
    REPEAT          reduce using rule 48 (exp -> exp EQ exp .)
    WHILE           reduce using rule 48 (exp -> exp EQ exp .)
    (               reduce using rule 48 (exp -> exp EQ exp .)
    NAME            reduce using rule 48 (exp -> exp EQ exp .)
    ]               reduce using rule 48 (exp -> exp EQ exp .)
    CONCAT          shift and go to state 85
    %               shift and go to state 86
    ^               shift and go to state 87
    /               shift and go to state 88
    *               shift and go to state 89
    -               shift and go to state 90
    +               shift and go to state 91


state 131

    (49) exp -> exp GE exp .
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    THEN            reduce using rule 49 (exp -> exp GE exp .)
    OR              reduce using rule 49 (exp -> exp GE exp .)
    AND             reduce using rule 49 (exp -> exp GE exp .)
    NE              reduce using rule 49 (exp -> exp GE exp .)
    EQ              reduce using rule 49 (exp -> exp GE exp .)
    GE              reduce using rule 49 (exp -> exp GE exp .)
    GT              reduce using rule 49 (exp -> exp GE exp .)
    LE              reduce using rule 49 (exp -> exp GE exp .)
    LT              reduce using rule 49 (exp -> exp GE exp .)
    DO              reduce using rule 49 (exp -> exp GE exp .)
    )               reduce using rule 49 (exp -> exp GE exp .)
    ,               reduce using rule 49 (exp -> exp GE exp .)
    ;               reduce using rule 49 (exp -> exp GE exp .)
    $end            reduce using rule 49 (exp -> exp GE exp .)
    END             reduce using rule 49 (exp -> exp GE exp .)
    UNTIL           reduce using rule 49 (exp -> exp GE exp .)
    ELSEIF          reduce using rule 49 (exp -> exp GE exp .)
    ELSE            reduce using rule 49 (exp -> exp GE exp .)
    }               reduce using rule 49 (exp -> exp GE exp .)
    BREAK           reduce using rule 49 (exp -> exp GE exp .)
    RETURN          reduce using rule 49 (exp -> exp GE exp .)
    LOCAL           reduce using rule 49 (exp -> exp GE exp .)
    FUNCTION        reduce using rule 49 (exp -> exp GE exp .)
    FOR             reduce using rule 49 (exp -> exp GE exp .)
    IF              reduce using rule 49 (exp -> exp GE exp .)
    REPEAT          reduce using rule 49 (exp -> exp GE exp .)
    WHILE           reduce using rule 49 (exp -> exp GE exp .)
    (               reduce using rule 49 (exp -> exp GE exp .)
    NAME            reduce using rule 49 (exp -> exp GE exp .)
    ]               reduce using rule 49 (exp -> exp GE exp .)
    CONCAT          shift and go to state 85
    %               shift and go to state 86
    ^               shift and go to state 87
    /               shift and go to state 88
    *               shift and go to state 89
    -               shift and go to state 90
    +               shift and go to state 91


state 132

    (50) exp -> exp GT exp .
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    THEN            reduce using rule 50 (exp -> exp GT exp .)
    OR              reduce using rule 50 (exp -> exp GT exp .)
    AND             reduce using rule 50 (exp -> exp GT exp .)
    NE              reduce using rule 50 (exp -> exp GT exp .)
    EQ              reduce using rule 50 (exp -> exp GT exp .)
    GE              reduce using rule 50 (exp -> exp GT exp .)
    GT              reduce using rule 50 (exp -> exp GT exp .)
    LE              reduce using rule 50 (exp -> exp GT exp .)
    LT              reduce using rule 50 (exp -> exp GT exp .)
    DO              reduce using rule 50 (exp -> exp GT exp .)
    )               reduce using rule 50 (exp -> exp GT exp .)
    ,               reduce using rule 50 (exp -> exp GT exp .)
    ;               reduce using rule 50 (exp -> exp GT exp .)
    $end            reduce using rule 50 (exp -> exp GT exp .)
    END             reduce using rule 50 (exp -> exp GT exp .)
    UNTIL           reduce using rule 50 (exp -> exp GT exp .)
    ELSEIF          reduce using rule 50 (exp -> exp GT exp .)
    ELSE            reduce using rule 50 (exp -> exp GT exp .)
    }               reduce using rule 50 (exp -> exp GT exp .)
    BREAK           reduce using rule 50 (exp -> exp GT exp .)
    RETURN          reduce using rule 50 (exp -> exp GT exp .)
    LOCAL           reduce using rule 50 (exp -> exp GT exp .)
    FUNCTION        reduce using rule 50 (exp -> exp GT exp .)
    FOR             reduce using rule 50 (exp -> exp GT exp .)
    IF              reduce using rule 50 (exp -> exp GT exp .)
    REPEAT          reduce using rule 50 (exp -> exp GT exp .)
    WHILE           reduce using rule 50 (exp -> exp GT exp .)
    (               reduce using rule 50 (exp -> exp GT exp .)
    NAME            reduce using rule 50 (exp -> exp GT exp .)
    ]               reduce using rule 50 (exp -> exp GT exp .)
    CONCAT          shift and go to state 85
    %               shift and go to state 86
    ^               shift and go to state 87
    /               shift and go to state 88
    *               shift and go to state 89
    -               shift and go to state 90
    +               shift and go to state 91


state 133

    (51) exp -> exp LE exp .
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    THEN            reduce using rule 51 (exp -> exp LE exp .)
    OR              reduce using rule 51 (exp -> exp LE exp .)
    AND             reduce using rule 51 (exp -> exp LE exp .)
    NE              reduce using rule 51 (exp -> exp LE exp .)
    EQ              reduce using rule 51 (exp -> exp LE exp .)
    GE              reduce using rule 51 (exp -> exp LE exp .)
    GT              reduce using rule 51 (exp -> exp LE exp .)
    LE              reduce using rule 51 (exp -> exp LE exp .)
    LT              reduce using rule 51 (exp -> exp LE exp .)
    DO              reduce using rule 51 (exp -> exp LE exp .)
    )               reduce using rule 51 (exp -> exp LE exp .)
    ,               reduce using rule 51 (exp -> exp LE exp .)
    ;               reduce using rule 51 (exp -> exp LE exp .)
    $end            reduce using rule 51 (exp -> exp LE exp .)
    END             reduce using rule 51 (exp -> exp LE exp .)
    UNTIL           reduce using rule 51 (exp -> exp LE exp .)
    ELSEIF          reduce using rule 51 (exp -> exp LE exp .)
    ELSE            reduce using rule 51 (exp -> exp LE exp .)
    }               reduce using rule 51 (exp -> exp LE exp .)
    BREAK           reduce using rule 51 (exp -> exp LE exp .)
    RETURN          reduce using rule 51 (exp -> exp LE exp .)
    LOCAL           reduce using rule 51 (exp -> exp LE exp .)
    FUNCTION        reduce using rule 51 (exp -> exp LE exp .)
    FOR             reduce using rule 51 (exp -> exp LE exp .)
    IF              reduce using rule 51 (exp -> exp LE exp .)
    REPEAT          reduce using rule 51 (exp -> exp LE exp .)
    WHILE           reduce using rule 51 (exp -> exp LE exp .)
    (               reduce using rule 51 (exp -> exp LE exp .)
    NAME            reduce using rule 51 (exp -> exp LE exp .)
    ]               reduce using rule 51 (exp -> exp LE exp .)
    CONCAT          shift and go to state 85
    %               shift and go to state 86
    ^               shift and go to state 87
    /               shift and go to state 88
    *               shift and go to state 89
    -               shift and go to state 90
    +               shift and go to state 91


state 134

    (52) exp -> exp LT exp .
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    THEN            reduce using rule 52 (exp -> exp LT exp .)
    OR              reduce using rule 52 (exp -> exp LT exp .)
    AND             reduce using rule 52 (exp -> exp LT exp .)
    NE              reduce using rule 52 (exp -> exp LT exp .)
    EQ              reduce using rule 52 (exp -> exp LT exp .)
    GE              reduce using rule 52 (exp -> exp LT exp .)
    GT              reduce using rule 52 (exp -> exp LT exp .)
    LE              reduce using rule 52 (exp -> exp LT exp .)
    LT              reduce using rule 52 (exp -> exp LT exp .)
    DO              reduce using rule 52 (exp -> exp LT exp .)
    )               reduce using rule 52 (exp -> exp LT exp .)
    ,               reduce using rule 52 (exp -> exp LT exp .)
    ;               reduce using rule 52 (exp -> exp LT exp .)
    $end            reduce using rule 52 (exp -> exp LT exp .)
    END             reduce using rule 52 (exp -> exp LT exp .)
    UNTIL           reduce using rule 52 (exp -> exp LT exp .)
    ELSEIF          reduce using rule 52 (exp -> exp LT exp .)
    ELSE            reduce using rule 52 (exp -> exp LT exp .)
    }               reduce using rule 52 (exp -> exp LT exp .)
    BREAK           reduce using rule 52 (exp -> exp LT exp .)
    RETURN          reduce using rule 52 (exp -> exp LT exp .)
    LOCAL           reduce using rule 52 (exp -> exp LT exp .)
    FUNCTION        reduce using rule 52 (exp -> exp LT exp .)
    FOR             reduce using rule 52 (exp -> exp LT exp .)
    IF              reduce using rule 52 (exp -> exp LT exp .)
    REPEAT          reduce using rule 52 (exp -> exp LT exp .)
    WHILE           reduce using rule 52 (exp -> exp LT exp .)
    (               reduce using rule 52 (exp -> exp LT exp .)
    NAME            reduce using rule 52 (exp -> exp LT exp .)
    ]               reduce using rule 52 (exp -> exp LT exp .)
    CONCAT          shift and go to state 85
    %               shift and go to state 86
    ^               shift and go to state 87
    /               shift and go to state 88
    *               shift and go to state 89
    -               shift and go to state 90
    +               shift and go to state 91


state 135

    (53) exp -> exp CONCAT exp .
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    THEN            reduce using rule 53 (exp -> exp CONCAT exp .)
    OR              reduce using rule 53 (exp -> exp CONCAT exp .)
    AND             reduce using rule 53 (exp -> exp CONCAT exp .)
    NE              reduce using rule 53 (exp -> exp CONCAT exp .)
    EQ              reduce using rule 53 (exp -> exp CONCAT exp .)
    GE              reduce using rule 53 (exp -> exp CONCAT exp .)
    GT              reduce using rule 53 (exp -> exp CONCAT exp .)
    LE              reduce using rule 53 (exp -> exp CONCAT exp .)
    LT              reduce using rule 53 (exp -> exp CONCAT exp .)
    DO              reduce using rule 53 (exp -> exp CONCAT exp .)
    )               reduce using rule 53 (exp -> exp CONCAT exp .)
    ,               reduce using rule 53 (exp -> exp CONCAT exp .)
    ;               reduce using rule 53 (exp -> exp CONCAT exp .)
    $end            reduce using rule 53 (exp -> exp CONCAT exp .)
    END             reduce using rule 53 (exp -> exp CONCAT exp .)
    UNTIL           reduce using rule 53 (exp -> exp CONCAT exp .)
    ELSEIF          reduce using rule 53 (exp -> exp CONCAT exp .)
    ELSE            reduce using rule 53 (exp -> exp CONCAT exp .)
    }               reduce using rule 53 (exp -> exp CONCAT exp .)
    BREAK           reduce using rule 53 (exp -> exp CONCAT exp .)
    RETURN          reduce using rule 53 (exp -> exp CONCAT exp .)
    LOCAL           reduce using rule 53 (exp -> exp CONCAT exp .)
    FUNCTION        reduce using rule 53 (exp -> exp CONCAT exp .)
    FOR             reduce using rule 53 (exp -> exp CONCAT exp .)
    IF              reduce using rule 53 (exp -> exp CONCAT exp .)
    REPEAT          reduce using rule 53 (exp -> exp CONCAT exp .)
    WHILE           reduce using rule 53 (exp -> exp CONCAT exp .)
    (               reduce using rule 53 (exp -> exp CONCAT exp .)
    NAME            reduce using rule 53 (exp -> exp CONCAT exp .)
    ]               reduce using rule 53 (exp -> exp CONCAT exp .)
    CONCAT          shift and go to state 85
    %               shift and go to state 86
    ^               shift and go to state 87
    /               shift and go to state 88
    *               shift and go to state 89
    -               shift and go to state 90
    +               shift and go to state 91


state 136

    (54) exp -> exp % exp .
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    THEN            reduce using rule 54 (exp -> exp % exp .)
    OR              reduce using rule 54 (exp -> exp % exp .)
    AND             reduce using rule 54 (exp -> exp % exp .)
    NE              reduce using rule 54 (exp -> exp % exp .)
    EQ              reduce using rule 54 (exp -> exp % exp .)
    GE              reduce using rule 54 (exp -> exp % exp .)
    GT              reduce using rule 54 (exp -> exp % exp .)
    LE              reduce using rule 54 (exp -> exp % exp .)
    LT              reduce using rule 54 (exp -> exp % exp .)
    CONCAT          reduce using rule 54 (exp -> exp % exp .)
    %               reduce using rule 54 (exp -> exp % exp .)
    /               reduce using rule 54 (exp -> exp % exp .)
    *               reduce using rule 54 (exp -> exp % exp .)
    -               reduce using rule 54 (exp -> exp % exp .)
    +               reduce using rule 54 (exp -> exp % exp .)
    DO              reduce using rule 54 (exp -> exp % exp .)
    )               reduce using rule 54 (exp -> exp % exp .)
    ,               reduce using rule 54 (exp -> exp % exp .)
    ;               reduce using rule 54 (exp -> exp % exp .)
    $end            reduce using rule 54 (exp -> exp % exp .)
    END             reduce using rule 54 (exp -> exp % exp .)
    UNTIL           reduce using rule 54 (exp -> exp % exp .)
    ELSEIF          reduce using rule 54 (exp -> exp % exp .)
    ELSE            reduce using rule 54 (exp -> exp % exp .)
    }               reduce using rule 54 (exp -> exp % exp .)
    BREAK           reduce using rule 54 (exp -> exp % exp .)
    RETURN          reduce using rule 54 (exp -> exp % exp .)
    LOCAL           reduce using rule 54 (exp -> exp % exp .)
    FUNCTION        reduce using rule 54 (exp -> exp % exp .)
    FOR             reduce using rule 54 (exp -> exp % exp .)
    IF              reduce using rule 54 (exp -> exp % exp .)
    REPEAT          reduce using rule 54 (exp -> exp % exp .)
    WHILE           reduce using rule 54 (exp -> exp % exp .)
    (               reduce using rule 54 (exp -> exp % exp .)
    NAME            reduce using rule 54 (exp -> exp % exp .)
    ]               reduce using rule 54 (exp -> exp % exp .)
    ^               shift and go to state 87


state 137

    (55) exp -> exp ^ exp .
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    THEN            reduce using rule 55 (exp -> exp ^ exp .)
    OR              reduce using rule 55 (exp -> exp ^ exp .)
    AND             reduce using rule 55 (exp -> exp ^ exp .)
    NE              reduce using rule 55 (exp -> exp ^ exp .)
    EQ              reduce using rule 55 (exp -> exp ^ exp .)
    GE              reduce using rule 55 (exp -> exp ^ exp .)
    GT              reduce using rule 55 (exp -> exp ^ exp .)
    LE              reduce using rule 55 (exp -> exp ^ exp .)
    LT              reduce using rule 55 (exp -> exp ^ exp .)
    CONCAT          reduce using rule 55 (exp -> exp ^ exp .)
    %               reduce using rule 55 (exp -> exp ^ exp .)
    /               reduce using rule 55 (exp -> exp ^ exp .)
    *               reduce using rule 55 (exp -> exp ^ exp .)
    -               reduce using rule 55 (exp -> exp ^ exp .)
    +               reduce using rule 55 (exp -> exp ^ exp .)
    DO              reduce using rule 55 (exp -> exp ^ exp .)
    )               reduce using rule 55 (exp -> exp ^ exp .)
    ,               reduce using rule 55 (exp -> exp ^ exp .)
    ;               reduce using rule 55 (exp -> exp ^ exp .)
    $end            reduce using rule 55 (exp -> exp ^ exp .)
    END             reduce using rule 55 (exp -> exp ^ exp .)
    UNTIL           reduce using rule 55 (exp -> exp ^ exp .)
    ELSEIF          reduce using rule 55 (exp -> exp ^ exp .)
    ELSE            reduce using rule 55 (exp -> exp ^ exp .)
    }               reduce using rule 55 (exp -> exp ^ exp .)
    BREAK           reduce using rule 55 (exp -> exp ^ exp .)
    RETURN          reduce using rule 55 (exp -> exp ^ exp .)
    LOCAL           reduce using rule 55 (exp -> exp ^ exp .)
    FUNCTION        reduce using rule 55 (exp -> exp ^ exp .)
    FOR             reduce using rule 55 (exp -> exp ^ exp .)
    IF              reduce using rule 55 (exp -> exp ^ exp .)
    REPEAT          reduce using rule 55 (exp -> exp ^ exp .)
    WHILE           reduce using rule 55 (exp -> exp ^ exp .)
    (               reduce using rule 55 (exp -> exp ^ exp .)
    NAME            reduce using rule 55 (exp -> exp ^ exp .)
    ]               reduce using rule 55 (exp -> exp ^ exp .)
    ^               shift and go to state 87


state 138

    (56) exp -> exp / exp .
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    THEN            reduce using rule 56 (exp -> exp / exp .)
    OR              reduce using rule 56 (exp -> exp / exp .)
    AND             reduce using rule 56 (exp -> exp / exp .)
    NE              reduce using rule 56 (exp -> exp / exp .)
    EQ              reduce using rule 56 (exp -> exp / exp .)
    GE              reduce using rule 56 (exp -> exp / exp .)
    GT              reduce using rule 56 (exp -> exp / exp .)
    LE              reduce using rule 56 (exp -> exp / exp .)
    LT              reduce using rule 56 (exp -> exp / exp .)
    CONCAT          reduce using rule 56 (exp -> exp / exp .)
    %               reduce using rule 56 (exp -> exp / exp .)
    /               reduce using rule 56 (exp -> exp / exp .)
    *               reduce using rule 56 (exp -> exp / exp .)
    -               reduce using rule 56 (exp -> exp / exp .)
    +               reduce using rule 56 (exp -> exp / exp .)
    DO              reduce using rule 56 (exp -> exp / exp .)
    )               reduce using rule 56 (exp -> exp / exp .)
    ,               reduce using rule 56 (exp -> exp / exp .)
    ;               reduce using rule 56 (exp -> exp / exp .)
    $end            reduce using rule 56 (exp -> exp / exp .)
    END             reduce using rule 56 (exp -> exp / exp .)
    UNTIL           reduce using rule 56 (exp -> exp / exp .)
    ELSEIF          reduce using rule 56 (exp -> exp / exp .)
    ELSE            reduce using rule 56 (exp -> exp / exp .)
    }               reduce using rule 56 (exp -> exp / exp .)
    BREAK           reduce using rule 56 (exp -> exp / exp .)
    RETURN          reduce using rule 56 (exp -> exp / exp .)
    LOCAL           reduce using rule 56 (exp -> exp / exp .)
    FUNCTION        reduce using rule 56 (exp -> exp / exp .)
    FOR             reduce using rule 56 (exp -> exp / exp .)
    IF              reduce using rule 56 (exp -> exp / exp .)
    REPEAT          reduce using rule 56 (exp -> exp / exp .)
    WHILE           reduce using rule 56 (exp -> exp / exp .)
    (               reduce using rule 56 (exp -> exp / exp .)
    NAME            reduce using rule 56 (exp -> exp / exp .)
    ]               reduce using rule 56 (exp -> exp / exp .)
    ^               shift and go to state 87


state 139

    (57) exp -> exp * exp .
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    THEN            reduce using rule 57 (exp -> exp * exp .)
    OR              reduce using rule 57 (exp -> exp * exp .)
    AND             reduce using rule 57 (exp -> exp * exp .)
    NE              reduce using rule 57 (exp -> exp * exp .)
    EQ              reduce using rule 57 (exp -> exp * exp .)
    GE              reduce using rule 57 (exp -> exp * exp .)
    GT              reduce using rule 57 (exp -> exp * exp .)
    LE              reduce using rule 57 (exp -> exp * exp .)
    LT              reduce using rule 57 (exp -> exp * exp .)
    CONCAT          reduce using rule 57 (exp -> exp * exp .)
    %               reduce using rule 57 (exp -> exp * exp .)
    /               reduce using rule 57 (exp -> exp * exp .)
    *               reduce using rule 57 (exp -> exp * exp .)
    -               reduce using rule 57 (exp -> exp * exp .)
    +               reduce using rule 57 (exp -> exp * exp .)
    DO              reduce using rule 57 (exp -> exp * exp .)
    )               reduce using rule 57 (exp -> exp * exp .)
    ,               reduce using rule 57 (exp -> exp * exp .)
    ;               reduce using rule 57 (exp -> exp * exp .)
    $end            reduce using rule 57 (exp -> exp * exp .)
    END             reduce using rule 57 (exp -> exp * exp .)
    UNTIL           reduce using rule 57 (exp -> exp * exp .)
    ELSEIF          reduce using rule 57 (exp -> exp * exp .)
    ELSE            reduce using rule 57 (exp -> exp * exp .)
    }               reduce using rule 57 (exp -> exp * exp .)
    BREAK           reduce using rule 57 (exp -> exp * exp .)
    RETURN          reduce using rule 57 (exp -> exp * exp .)
    LOCAL           reduce using rule 57 (exp -> exp * exp .)
    FUNCTION        reduce using rule 57 (exp -> exp * exp .)
    FOR             reduce using rule 57 (exp -> exp * exp .)
    IF              reduce using rule 57 (exp -> exp * exp .)
    REPEAT          reduce using rule 57 (exp -> exp * exp .)
    WHILE           reduce using rule 57 (exp -> exp * exp .)
    (               reduce using rule 57 (exp -> exp * exp .)
    NAME            reduce using rule 57 (exp -> exp * exp .)
    ]               reduce using rule 57 (exp -> exp * exp .)
    ^               shift and go to state 87


state 140

    (58) exp -> exp - exp .
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    THEN            reduce using rule 58 (exp -> exp - exp .)
    OR              reduce using rule 58 (exp -> exp - exp .)
    AND             reduce using rule 58 (exp -> exp - exp .)
    NE              reduce using rule 58 (exp -> exp - exp .)
    EQ              reduce using rule 58 (exp -> exp - exp .)
    GE              reduce using rule 58 (exp -> exp - exp .)
    GT              reduce using rule 58 (exp -> exp - exp .)
    LE              reduce using rule 58 (exp -> exp - exp .)
    LT              reduce using rule 58 (exp -> exp - exp .)
    CONCAT          reduce using rule 58 (exp -> exp - exp .)
    -               reduce using rule 58 (exp -> exp - exp .)
    +               reduce using rule 58 (exp -> exp - exp .)
    DO              reduce using rule 58 (exp -> exp - exp .)
    )               reduce using rule 58 (exp -> exp - exp .)
    ,               reduce using rule 58 (exp -> exp - exp .)
    ;               reduce using rule 58 (exp -> exp - exp .)
    $end            reduce using rule 58 (exp -> exp - exp .)
    END             reduce using rule 58 (exp -> exp - exp .)
    UNTIL           reduce using rule 58 (exp -> exp - exp .)
    ELSEIF          reduce using rule 58 (exp -> exp - exp .)
    ELSE            reduce using rule 58 (exp -> exp - exp .)
    }               reduce using rule 58 (exp -> exp - exp .)
    BREAK           reduce using rule 58 (exp -> exp - exp .)
    RETURN          reduce using rule 58 (exp -> exp - exp .)
    LOCAL           reduce using rule 58 (exp -> exp - exp .)
    FUNCTION        reduce using rule 58 (exp -> exp - exp .)
    FOR             reduce using rule 58 (exp -> exp - exp .)
    IF              reduce using rule 58 (exp -> exp - exp .)
    REPEAT          reduce using rule 58 (exp -> exp - exp .)
    WHILE           reduce using rule 58 (exp -> exp - exp .)
    (               reduce using rule 58 (exp -> exp - exp .)
    NAME            reduce using rule 58 (exp -> exp - exp .)
    ]               reduce using rule 58 (exp -> exp - exp .)
    %               shift and go to state 86
    ^               shift and go to state 87
    /               shift and go to state 88
    *               shift and go to state 89


state 141

    (59) exp -> exp + exp .
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    THEN            reduce using rule 59 (exp -> exp + exp .)
    OR              reduce using rule 59 (exp -> exp + exp .)
    AND             reduce using rule 59 (exp -> exp + exp .)
    NE              reduce using rule 59 (exp -> exp + exp .)
    EQ              reduce using rule 59 (exp -> exp + exp .)
    GE              reduce using rule 59 (exp -> exp + exp .)
    GT              reduce using rule 59 (exp -> exp + exp .)
    LE              reduce using rule 59 (exp -> exp + exp .)
    LT              reduce using rule 59 (exp -> exp + exp .)
    CONCAT          reduce using rule 59 (exp -> exp + exp .)
    -               reduce using rule 59 (exp -> exp + exp .)
    +               reduce using rule 59 (exp -> exp + exp .)
    DO              reduce using rule 59 (exp -> exp + exp .)
    )               reduce using rule 59 (exp -> exp + exp .)
    ,               reduce using rule 59 (exp -> exp + exp .)
    ;               reduce using rule 59 (exp -> exp + exp .)
    $end            reduce using rule 59 (exp -> exp + exp .)
    END             reduce using rule 59 (exp -> exp + exp .)
    UNTIL           reduce using rule 59 (exp -> exp + exp .)
    ELSEIF          reduce using rule 59 (exp -> exp + exp .)
    ELSE            reduce using rule 59 (exp -> exp + exp .)
    }               reduce using rule 59 (exp -> exp + exp .)
    BREAK           reduce using rule 59 (exp -> exp + exp .)
    RETURN          reduce using rule 59 (exp -> exp + exp .)
    LOCAL           reduce using rule 59 (exp -> exp + exp .)
    FUNCTION        reduce using rule 59 (exp -> exp + exp .)
    FOR             reduce using rule 59 (exp -> exp + exp .)
    IF              reduce using rule 59 (exp -> exp + exp .)
    REPEAT          reduce using rule 59 (exp -> exp + exp .)
    WHILE           reduce using rule 59 (exp -> exp + exp .)
    (               reduce using rule 59 (exp -> exp + exp .)
    NAME            reduce using rule 59 (exp -> exp + exp .)
    ]               reduce using rule 59 (exp -> exp + exp .)
    %               shift and go to state 86
    ^               shift and go to state 87
    /               shift and go to state 88
    *               shift and go to state 89


state 142

    (84) tableconstructor -> { fieldlist } .
    THEN            reduce using rule 84 (tableconstructor -> { fieldlist } .)
    OR              reduce using rule 84 (tableconstructor -> { fieldlist } .)
    AND             reduce using rule 84 (tableconstructor -> { fieldlist } .)
    NE              reduce using rule 84 (tableconstructor -> { fieldlist } .)
    EQ              reduce using rule 84 (tableconstructor -> { fieldlist } .)
    GE              reduce using rule 84 (tableconstructor -> { fieldlist } .)
    GT              reduce using rule 84 (tableconstructor -> { fieldlist } .)
    LE              reduce using rule 84 (tableconstructor -> { fieldlist } .)
    LT              reduce using rule 84 (tableconstructor -> { fieldlist } .)
    CONCAT          reduce using rule 84 (tableconstructor -> { fieldlist } .)
    %               reduce using rule 84 (tableconstructor -> { fieldlist } .)
    ^               reduce using rule 84 (tableconstructor -> { fieldlist } .)
    /               reduce using rule 84 (tableconstructor -> { fieldlist } .)
    *               reduce using rule 84 (tableconstructor -> { fieldlist } .)
    -               reduce using rule 84 (tableconstructor -> { fieldlist } .)
    +               reduce using rule 84 (tableconstructor -> { fieldlist } .)
    DO              reduce using rule 84 (tableconstructor -> { fieldlist } .)
    .               reduce using rule 84 (tableconstructor -> { fieldlist } .)
    [               reduce using rule 84 (tableconstructor -> { fieldlist } .)
    :               reduce using rule 84 (tableconstructor -> { fieldlist } .)
    STRING          reduce using rule 84 (tableconstructor -> { fieldlist } .)
    (               reduce using rule 84 (tableconstructor -> { fieldlist } .)
    {               reduce using rule 84 (tableconstructor -> { fieldlist } .)
    )               reduce using rule 84 (tableconstructor -> { fieldlist } .)
    ,               reduce using rule 84 (tableconstructor -> { fieldlist } .)
    ;               reduce using rule 84 (tableconstructor -> { fieldlist } .)
    $end            reduce using rule 84 (tableconstructor -> { fieldlist } .)
    END             reduce using rule 84 (tableconstructor -> { fieldlist } .)
    UNTIL           reduce using rule 84 (tableconstructor -> { fieldlist } .)
    ELSEIF          reduce using rule 84 (tableconstructor -> { fieldlist } .)
    ELSE            reduce using rule 84 (tableconstructor -> { fieldlist } .)
    }               reduce using rule 84 (tableconstructor -> { fieldlist } .)
    BREAK           reduce using rule 84 (tableconstructor -> { fieldlist } .)
    RETURN          reduce using rule 84 (tableconstructor -> { fieldlist } .)
    LOCAL           reduce using rule 84 (tableconstructor -> { fieldlist } .)
    FUNCTION        reduce using rule 84 (tableconstructor -> { fieldlist } .)
    FOR             reduce using rule 84 (tableconstructor -> { fieldlist } .)
    IF              reduce using rule 84 (tableconstructor -> { fieldlist } .)
    REPEAT          reduce using rule 84 (tableconstructor -> { fieldlist } .)
    WHILE           reduce using rule 84 (tableconstructor -> { fieldlist } .)
    NAME            reduce using rule 84 (tableconstructor -> { fieldlist } .)
    ]               reduce using rule 84 (tableconstructor -> { fieldlist } .)


state 143

    (85) fieldlist -> fieldlist2 optfieldsep .
    }               reduce using rule 85 (fieldlist -> fieldlist2 optfieldsep .)


state 144

    (86) fieldlist2 -> fieldlist2 fieldsep . field
    (92) optfieldsep -> fieldsep .
    (88) field -> . exp
    (89) field -> . NAME = exp
    (90) field -> . [ exp ] = exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    }               reduce using rule 92 (optfieldsep -> fieldsep .)
    NAME            shift and go to state 100
    [               shift and go to state 101
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    field                          shift and go to state 165
    exp                            shift and go to state 99
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 145

    (91) optfieldsep -> empty .
    }               reduce using rule 91 (optfieldsep -> empty .)


state 146

    (93) fieldsep -> ; .
    NAME            reduce using rule 93 (fieldsep -> ; .)
    [               reduce using rule 93 (fieldsep -> ; .)
    #               reduce using rule 93 (fieldsep -> ; .)
    NOT             reduce using rule 93 (fieldsep -> ; .)
    -               reduce using rule 93 (fieldsep -> ; .)
    VARARG          reduce using rule 93 (fieldsep -> ; .)
    STRING          reduce using rule 93 (fieldsep -> ; .)
    NUMBER          reduce using rule 93 (fieldsep -> ; .)
    TRUE            reduce using rule 93 (fieldsep -> ; .)
    FALSE           reduce using rule 93 (fieldsep -> ; .)
    NIL             reduce using rule 93 (fieldsep -> ; .)
    {               reduce using rule 93 (fieldsep -> ; .)
    FUNCTION        reduce using rule 93 (fieldsep -> ; .)
    }               reduce using rule 93 (fieldsep -> ; .)


state 147

    (94) fieldsep -> , .
    NAME            reduce using rule 94 (fieldsep -> , .)
    [               reduce using rule 94 (fieldsep -> , .)
    #               reduce using rule 94 (fieldsep -> , .)
    NOT             reduce using rule 94 (fieldsep -> , .)
    -               reduce using rule 94 (fieldsep -> , .)
    VARARG          reduce using rule 94 (fieldsep -> , .)
    STRING          reduce using rule 94 (fieldsep -> , .)
    NUMBER          reduce using rule 94 (fieldsep -> , .)
    TRUE            reduce using rule 94 (fieldsep -> , .)
    FALSE           reduce using rule 94 (fieldsep -> , .)
    NIL             reduce using rule 94 (fieldsep -> , .)
    {               reduce using rule 94 (fieldsep -> , .)
    FUNCTION        reduce using rule 94 (fieldsep -> , .)
    }               reduce using rule 94 (fieldsep -> , .)


state 148

    (89) field -> NAME = . exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 166
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 149

    (90) field -> [ exp . ] = exp
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    ]               shift and go to state 167
    OR              shift and go to state 77
    AND             shift and go to state 78
    NE              shift and go to state 79
    EQ              shift and go to state 80
    GE              shift and go to state 81
    GT              shift and go to state 82
    LE              shift and go to state 83
    LT              shift and go to state 84
    CONCAT          shift and go to state 85
    %               shift and go to state 86
    ^               shift and go to state 87
    /               shift and go to state 88
    *               shift and go to state 89
    -               shift and go to state 90
    +               shift and go to state 91


state 150

    (15) stat -> REPEAT block UNTIL exp .
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    ;               reduce using rule 15 (stat -> REPEAT block UNTIL exp .)
    BREAK           reduce using rule 15 (stat -> REPEAT block UNTIL exp .)
    RETURN          reduce using rule 15 (stat -> REPEAT block UNTIL exp .)
    LOCAL           reduce using rule 15 (stat -> REPEAT block UNTIL exp .)
    FUNCTION        reduce using rule 15 (stat -> REPEAT block UNTIL exp .)
    FOR             reduce using rule 15 (stat -> REPEAT block UNTIL exp .)
    IF              reduce using rule 15 (stat -> REPEAT block UNTIL exp .)
    REPEAT          reduce using rule 15 (stat -> REPEAT block UNTIL exp .)
    WHILE           reduce using rule 15 (stat -> REPEAT block UNTIL exp .)
    DO              reduce using rule 15 (stat -> REPEAT block UNTIL exp .)
    (               reduce using rule 15 (stat -> REPEAT block UNTIL exp .)
    NAME            reduce using rule 15 (stat -> REPEAT block UNTIL exp .)
    OR              shift and go to state 77
    AND             shift and go to state 78
    NE              shift and go to state 79
    EQ              shift and go to state 80
    GE              shift and go to state 81
    GT              shift and go to state 82
    LE              shift and go to state 83
    LT              shift and go to state 84
    CONCAT          shift and go to state 85
    %               shift and go to state 86
    ^               shift and go to state 87
    /               shift and go to state 88
    *               shift and go to state 89
    -               shift and go to state 90
    +               shift and go to state 91


state 151

    (16) stat -> WHILE exp DO block . END
    END             shift and go to state 168


state 152

    (35) var -> prefixexp [ exp ] .
    =               reduce using rule 35 (var -> prefixexp [ exp ] .)
    ,               reduce using rule 35 (var -> prefixexp [ exp ] .)
    .               reduce using rule 35 (var -> prefixexp [ exp ] .)
    [               reduce using rule 35 (var -> prefixexp [ exp ] .)
    :               reduce using rule 35 (var -> prefixexp [ exp ] .)
    STRING          reduce using rule 35 (var -> prefixexp [ exp ] .)
    (               reduce using rule 35 (var -> prefixexp [ exp ] .)
    {               reduce using rule 35 (var -> prefixexp [ exp ] .)


state 153

    (71) functioncall -> prefixexp : name args .
    .               reduce using rule 71 (functioncall -> prefixexp : name args .)
    [               reduce using rule 71 (functioncall -> prefixexp : name args .)
    :               reduce using rule 71 (functioncall -> prefixexp : name args .)
    STRING          reduce using rule 71 (functioncall -> prefixexp : name args .)
    (               reduce using rule 71 (functioncall -> prefixexp : name args .)
    {               reduce using rule 71 (functioncall -> prefixexp : name args .)


state 154

    (75) args -> ( explist ) .
    .               reduce using rule 75 (args -> ( explist ) .)
    [               reduce using rule 75 (args -> ( explist ) .)
    :               reduce using rule 75 (args -> ( explist ) .)
    STRING          reduce using rule 75 (args -> ( explist ) .)
    (               reduce using rule 75 (args -> ( explist ) .)
    {               reduce using rule 75 (args -> ( explist ) .)


state 155

    (41) explist -> explist , exp .
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    ,               reduce using rule 41 (explist -> explist , exp .)
    ;               reduce using rule 41 (explist -> explist , exp .)
    $end            reduce using rule 41 (explist -> explist , exp .)
    END             reduce using rule 41 (explist -> explist , exp .)
    UNTIL           reduce using rule 41 (explist -> explist , exp .)
    ELSEIF          reduce using rule 41 (explist -> explist , exp .)
    ELSE            reduce using rule 41 (explist -> explist , exp .)
    BREAK           reduce using rule 41 (explist -> explist , exp .)
    RETURN          reduce using rule 41 (explist -> explist , exp .)
    LOCAL           reduce using rule 41 (explist -> explist , exp .)
    FUNCTION        reduce using rule 41 (explist -> explist , exp .)
    FOR             reduce using rule 41 (explist -> explist , exp .)
    IF              reduce using rule 41 (explist -> explist , exp .)
    REPEAT          reduce using rule 41 (explist -> explist , exp .)
    WHILE           reduce using rule 41 (explist -> explist , exp .)
    DO              reduce using rule 41 (explist -> explist , exp .)
    (               reduce using rule 41 (explist -> explist , exp .)
    NAME            reduce using rule 41 (explist -> explist , exp .)
    )               reduce using rule 41 (explist -> explist , exp .)
    OR              shift and go to state 77
    AND             shift and go to state 78
    NE              shift and go to state 79
    EQ              shift and go to state 80
    GE              shift and go to state 81
    GT              shift and go to state 82
    LE              shift and go to state 83
    LT              shift and go to state 84
    CONCAT          shift and go to state 85
    %               shift and go to state 86
    ^               shift and go to state 87
    /               shift and go to state 88
    *               shift and go to state 89
    -               shift and go to state 90
    +               shift and go to state 91


state 156

    (78) funcbody -> ( ) block . END
    END             shift and go to state 169


state 157

    (79) funcbody -> ( parlist ) . block END
    (4) block -> . chunk
    (1) chunk -> . chunk2 laststat
    (2) chunk2 -> . chunk2 stat optsemi
    (3) chunk2 -> . stat optsemi
    (7) stat -> . LOCAL namelist = explist
    (8) stat -> . LOCAL namelist
    (9) stat -> . LOCAL FUNCTION name funcbody
    (10) stat -> . FUNCTION funcname funcbody
    (11) stat -> . FOR namelist IN explist DO block END
    (12) stat -> . FOR name = exp , exp , exp DO block END
    (13) stat -> . FOR name = exp , exp DO block END
    (14) stat -> . IF exp THEN block elseiflist _else END
    (15) stat -> . REPEAT block UNTIL exp
    (16) stat -> . WHILE exp DO block END
    (17) stat -> . DO block END
    (18) stat -> . varlist = explist
    (32) varlist -> . var
    (33) varlist -> . varlist , var
    (34) var -> . prefixexp . name
    (35) var -> . prefixexp [ exp ]
    (36) var -> . name
    (68) prefixexp -> . ( exp )
    (69) prefixexp -> . functioncall
    (70) prefixexp -> . var
    (37) name -> . NAME
    (71) functioncall -> . prefixexp : name args
    (72) functioncall -> . prefixexp args
    LOCAL           shift and go to state 4
    FUNCTION        shift and go to state 5
    FOR             shift and go to state 7
    IF              shift and go to state 9
    REPEAT          shift and go to state 10
    WHILE           shift and go to state 11
    DO              shift and go to state 8
    (               shift and go to state 15
    NAME            shift and go to state 17

    block                          shift and go to state 170
    chunk                          shift and go to state 34
    chunk2                         shift and go to state 2
    stat                           shift and go to state 3
    name                           shift and go to state 6
    varlist                        shift and go to state 12
    var                            shift and go to state 13
    prefixexp                      shift and go to state 14
    functioncall                   shift and go to state 16

state 158

    (81) parlist -> namelist , . VARARG
    (39) namelist -> namelist , . name
    (37) name -> . NAME
    VARARG          shift and go to state 171
    NAME            shift and go to state 17

    name                           shift and go to state 116

state 159

    (11) stat -> FOR namelist IN explist DO . block END
    (4) block -> . chunk
    (1) chunk -> . chunk2 laststat
    (2) chunk2 -> . chunk2 stat optsemi
    (3) chunk2 -> . stat optsemi
    (7) stat -> . LOCAL namelist = explist
    (8) stat -> . LOCAL namelist
    (9) stat -> . LOCAL FUNCTION name funcbody
    (10) stat -> . FUNCTION funcname funcbody
    (11) stat -> . FOR namelist IN explist DO block END
    (12) stat -> . FOR name = exp , exp , exp DO block END
    (13) stat -> . FOR name = exp , exp DO block END
    (14) stat -> . IF exp THEN block elseiflist _else END
    (15) stat -> . REPEAT block UNTIL exp
    (16) stat -> . WHILE exp DO block END
    (17) stat -> . DO block END
    (18) stat -> . varlist = explist
    (32) varlist -> . var
    (33) varlist -> . varlist , var
    (34) var -> . prefixexp . name
    (35) var -> . prefixexp [ exp ]
    (36) var -> . name
    (68) prefixexp -> . ( exp )
    (69) prefixexp -> . functioncall
    (70) prefixexp -> . var
    (37) name -> . NAME
    (71) functioncall -> . prefixexp : name args
    (72) functioncall -> . prefixexp args
    LOCAL           shift and go to state 4
    FUNCTION        shift and go to state 5
    FOR             shift and go to state 7
    IF              shift and go to state 9
    REPEAT          shift and go to state 10
    WHILE           shift and go to state 11
    DO              shift and go to state 8
    (               shift and go to state 15
    NAME            shift and go to state 17

    block                          shift and go to state 172
    chunk                          shift and go to state 34
    chunk2                         shift and go to state 2
    stat                           shift and go to state 3
    name                           shift and go to state 6
    varlist                        shift and go to state 12
    var                            shift and go to state 13
    prefixexp                      shift and go to state 14
    functioncall                   shift and go to state 16

state 160

    (12) stat -> FOR name = exp , . exp , exp DO block END
    (13) stat -> FOR name = exp , . exp DO block END
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 173
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 161

    (14) stat -> IF exp THEN block elseiflist . _else END
    (20) elseiflist -> elseiflist . elseif
    (23) _else -> . empty
    (24) _else -> . ELSE block
    (22) elseif -> . ELSEIF exp THEN block
    (95) empty -> .
    ELSE            shift and go to state 177
    ELSEIF          shift and go to state 164
    END             reduce using rule 95 (empty -> .)

    _else                          shift and go to state 174
    elseif                         shift and go to state 175
    empty                          shift and go to state 176

state 162

    (19) elseiflist -> empty .
    ELSE            reduce using rule 19 (elseiflist -> empty .)
    ELSEIF          reduce using rule 19 (elseiflist -> empty .)
    END             reduce using rule 19 (elseiflist -> empty .)


state 163

    (21) elseiflist -> elseif .
    ELSE            reduce using rule 21 (elseiflist -> elseif .)
    ELSEIF          reduce using rule 21 (elseiflist -> elseif .)
    END             reduce using rule 21 (elseiflist -> elseif .)


state 164

    (22) elseif -> ELSEIF . exp THEN block
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 178
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 165

    (86) fieldlist2 -> fieldlist2 fieldsep field .
    ;               reduce using rule 86 (fieldlist2 -> fieldlist2 fieldsep field .)
    ,               reduce using rule 86 (fieldlist2 -> fieldlist2 fieldsep field .)
    }               reduce using rule 86 (fieldlist2 -> fieldlist2 fieldsep field .)


state 166

    (89) field -> NAME = exp .
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    ;               reduce using rule 89 (field -> NAME = exp .)
    ,               reduce using rule 89 (field -> NAME = exp .)
    }               reduce using rule 89 (field -> NAME = exp .)
    OR              shift and go to state 77
    AND             shift and go to state 78
    NE              shift and go to state 79
    EQ              shift and go to state 80
    GE              shift and go to state 81
    GT              shift and go to state 82
    LE              shift and go to state 83
    LT              shift and go to state 84
    CONCAT          shift and go to state 85
    %               shift and go to state 86
    ^               shift and go to state 87
    /               shift and go to state 88
    *               shift and go to state 89
    -               shift and go to state 90
    +               shift and go to state 91


state 167

    (90) field -> [ exp ] . = exp
    =               shift and go to state 179


state 168

    (16) stat -> WHILE exp DO block END .
    ;               reduce using rule 16 (stat -> WHILE exp DO block END .)
    BREAK           reduce using rule 16 (stat -> WHILE exp DO block END .)
    RETURN          reduce using rule 16 (stat -> WHILE exp DO block END .)
    LOCAL           reduce using rule 16 (stat -> WHILE exp DO block END .)
    FUNCTION        reduce using rule 16 (stat -> WHILE exp DO block END .)
    FOR             reduce using rule 16 (stat -> WHILE exp DO block END .)
    IF              reduce using rule 16 (stat -> WHILE exp DO block END .)
    REPEAT          reduce using rule 16 (stat -> WHILE exp DO block END .)
    WHILE           reduce using rule 16 (stat -> WHILE exp DO block END .)
    DO              reduce using rule 16 (stat -> WHILE exp DO block END .)
    (               reduce using rule 16 (stat -> WHILE exp DO block END .)
    NAME            reduce using rule 16 (stat -> WHILE exp DO block END .)


state 169

    (78) funcbody -> ( ) block END .
    ;               reduce using rule 78 (funcbody -> ( ) block END .)
    BREAK           reduce using rule 78 (funcbody -> ( ) block END .)
    RETURN          reduce using rule 78 (funcbody -> ( ) block END .)
    LOCAL           reduce using rule 78 (funcbody -> ( ) block END .)
    FUNCTION        reduce using rule 78 (funcbody -> ( ) block END .)
    FOR             reduce using rule 78 (funcbody -> ( ) block END .)
    IF              reduce using rule 78 (funcbody -> ( ) block END .)
    REPEAT          reduce using rule 78 (funcbody -> ( ) block END .)
    WHILE           reduce using rule 78 (funcbody -> ( ) block END .)
    DO              reduce using rule 78 (funcbody -> ( ) block END .)
    (               reduce using rule 78 (funcbody -> ( ) block END .)
    NAME            reduce using rule 78 (funcbody -> ( ) block END .)
    THEN            reduce using rule 78 (funcbody -> ( ) block END .)
    OR              reduce using rule 78 (funcbody -> ( ) block END .)
    AND             reduce using rule 78 (funcbody -> ( ) block END .)
    NE              reduce using rule 78 (funcbody -> ( ) block END .)
    EQ              reduce using rule 78 (funcbody -> ( ) block END .)
    GE              reduce using rule 78 (funcbody -> ( ) block END .)
    GT              reduce using rule 78 (funcbody -> ( ) block END .)
    LE              reduce using rule 78 (funcbody -> ( ) block END .)
    LT              reduce using rule 78 (funcbody -> ( ) block END .)
    CONCAT          reduce using rule 78 (funcbody -> ( ) block END .)
    %               reduce using rule 78 (funcbody -> ( ) block END .)
    ^               reduce using rule 78 (funcbody -> ( ) block END .)
    /               reduce using rule 78 (funcbody -> ( ) block END .)
    *               reduce using rule 78 (funcbody -> ( ) block END .)
    -               reduce using rule 78 (funcbody -> ( ) block END .)
    +               reduce using rule 78 (funcbody -> ( ) block END .)
    )               reduce using rule 78 (funcbody -> ( ) block END .)
    ,               reduce using rule 78 (funcbody -> ( ) block END .)
    $end            reduce using rule 78 (funcbody -> ( ) block END .)
    END             reduce using rule 78 (funcbody -> ( ) block END .)
    UNTIL           reduce using rule 78 (funcbody -> ( ) block END .)
    ELSEIF          reduce using rule 78 (funcbody -> ( ) block END .)
    ELSE            reduce using rule 78 (funcbody -> ( ) block END .)
    }               reduce using rule 78 (funcbody -> ( ) block END .)
    ]               reduce using rule 78 (funcbody -> ( ) block END .)


state 170

    (79) funcbody -> ( parlist ) block . END
    END             shift and go to state 180


state 171

    (81) parlist -> namelist , VARARG .
    )               reduce using rule 81 (parlist -> namelist , VARARG .)


state 172

    (11) stat -> FOR namelist IN explist DO block . END
    END             shift and go to state 181


state 173

    (12) stat -> FOR name = exp , exp . , exp DO block END
    (13) stat -> FOR name = exp , exp . DO block END
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    ,               shift and go to state 182
    DO              shift and go to state 183
    OR              shift and go to state 77
    AND             shift and go to state 78
    NE              shift and go to state 79
    EQ              shift and go to state 80
    GE              shift and go to state 81
    GT              shift and go to state 82
    LE              shift and go to state 83
    LT              shift and go to state 84
    CONCAT          shift and go to state 85
    %               shift and go to state 86
    ^               shift and go to state 87
    /               shift and go to state 88
    *               shift and go to state 89
    -               shift and go to state 90
    +               shift and go to state 91


state 174

    (14) stat -> IF exp THEN block elseiflist _else . END
    END             shift and go to state 184


state 175

    (20) elseiflist -> elseiflist elseif .
    ELSE            reduce using rule 20 (elseiflist -> elseiflist elseif .)
    ELSEIF          reduce using rule 20 (elseiflist -> elseiflist elseif .)
    END             reduce using rule 20 (elseiflist -> elseiflist elseif .)


state 176

    (23) _else -> empty .
    END             reduce using rule 23 (_else -> empty .)


state 177

    (24) _else -> ELSE . block
    (4) block -> . chunk
    (1) chunk -> . chunk2 laststat
    (2) chunk2 -> . chunk2 stat optsemi
    (3) chunk2 -> . stat optsemi
    (7) stat -> . LOCAL namelist = explist
    (8) stat -> . LOCAL namelist
    (9) stat -> . LOCAL FUNCTION name funcbody
    (10) stat -> . FUNCTION funcname funcbody
    (11) stat -> . FOR namelist IN explist DO block END
    (12) stat -> . FOR name = exp , exp , exp DO block END
    (13) stat -> . FOR name = exp , exp DO block END
    (14) stat -> . IF exp THEN block elseiflist _else END
    (15) stat -> . REPEAT block UNTIL exp
    (16) stat -> . WHILE exp DO block END
    (17) stat -> . DO block END
    (18) stat -> . varlist = explist
    (32) varlist -> . var
    (33) varlist -> . varlist , var
    (34) var -> . prefixexp . name
    (35) var -> . prefixexp [ exp ]
    (36) var -> . name
    (68) prefixexp -> . ( exp )
    (69) prefixexp -> . functioncall
    (70) prefixexp -> . var
    (37) name -> . NAME
    (71) functioncall -> . prefixexp : name args
    (72) functioncall -> . prefixexp args
    LOCAL           shift and go to state 4
    FUNCTION        shift and go to state 5
    FOR             shift and go to state 7
    IF              shift and go to state 9
    REPEAT          shift and go to state 10
    WHILE           shift and go to state 11
    DO              shift and go to state 8
    (               shift and go to state 15
    NAME            shift and go to state 17

    block                          shift and go to state 185
    chunk                          shift and go to state 34
    chunk2                         shift and go to state 2
    stat                           shift and go to state 3
    name                           shift and go to state 6
    varlist                        shift and go to state 12
    var                            shift and go to state 13
    prefixexp                      shift and go to state 14
    functioncall                   shift and go to state 16

state 178

    (22) elseif -> ELSEIF exp . THEN block
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    THEN            shift and go to state 186
    OR              shift and go to state 77
    AND             shift and go to state 78
    NE              shift and go to state 79
    EQ              shift and go to state 80
    GE              shift and go to state 81
    GT              shift and go to state 82
    LE              shift and go to state 83
    LT              shift and go to state 84
    CONCAT          shift and go to state 85
    %               shift and go to state 86
    ^               shift and go to state 87
    /               shift and go to state 88
    *               shift and go to state 89
    -               shift and go to state 90
    +               shift and go to state 91


state 179

    (90) field -> [ exp ] = . exp
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 187
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 180

    (79) funcbody -> ( parlist ) block END .
    ;               reduce using rule 79 (funcbody -> ( parlist ) block END .)
    BREAK           reduce using rule 79 (funcbody -> ( parlist ) block END .)
    RETURN          reduce using rule 79 (funcbody -> ( parlist ) block END .)
    LOCAL           reduce using rule 79 (funcbody -> ( parlist ) block END .)
    FUNCTION        reduce using rule 79 (funcbody -> ( parlist ) block END .)
    FOR             reduce using rule 79 (funcbody -> ( parlist ) block END .)
    IF              reduce using rule 79 (funcbody -> ( parlist ) block END .)
    REPEAT          reduce using rule 79 (funcbody -> ( parlist ) block END .)
    WHILE           reduce using rule 79 (funcbody -> ( parlist ) block END .)
    DO              reduce using rule 79 (funcbody -> ( parlist ) block END .)
    (               reduce using rule 79 (funcbody -> ( parlist ) block END .)
    NAME            reduce using rule 79 (funcbody -> ( parlist ) block END .)
    THEN            reduce using rule 79 (funcbody -> ( parlist ) block END .)
    OR              reduce using rule 79 (funcbody -> ( parlist ) block END .)
    AND             reduce using rule 79 (funcbody -> ( parlist ) block END .)
    NE              reduce using rule 79 (funcbody -> ( parlist ) block END .)
    EQ              reduce using rule 79 (funcbody -> ( parlist ) block END .)
    GE              reduce using rule 79 (funcbody -> ( parlist ) block END .)
    GT              reduce using rule 79 (funcbody -> ( parlist ) block END .)
    LE              reduce using rule 79 (funcbody -> ( parlist ) block END .)
    LT              reduce using rule 79 (funcbody -> ( parlist ) block END .)
    CONCAT          reduce using rule 79 (funcbody -> ( parlist ) block END .)
    %               reduce using rule 79 (funcbody -> ( parlist ) block END .)
    ^               reduce using rule 79 (funcbody -> ( parlist ) block END .)
    /               reduce using rule 79 (funcbody -> ( parlist ) block END .)
    *               reduce using rule 79 (funcbody -> ( parlist ) block END .)
    -               reduce using rule 79 (funcbody -> ( parlist ) block END .)
    +               reduce using rule 79 (funcbody -> ( parlist ) block END .)
    )               reduce using rule 79 (funcbody -> ( parlist ) block END .)
    ,               reduce using rule 79 (funcbody -> ( parlist ) block END .)
    $end            reduce using rule 79 (funcbody -> ( parlist ) block END .)
    END             reduce using rule 79 (funcbody -> ( parlist ) block END .)
    UNTIL           reduce using rule 79 (funcbody -> ( parlist ) block END .)
    ELSEIF          reduce using rule 79 (funcbody -> ( parlist ) block END .)
    ELSE            reduce using rule 79 (funcbody -> ( parlist ) block END .)
    }               reduce using rule 79 (funcbody -> ( parlist ) block END .)
    ]               reduce using rule 79 (funcbody -> ( parlist ) block END .)


state 181

    (11) stat -> FOR namelist IN explist DO block END .
    ;               reduce using rule 11 (stat -> FOR namelist IN explist DO block END .)
    BREAK           reduce using rule 11 (stat -> FOR namelist IN explist DO block END .)
    RETURN          reduce using rule 11 (stat -> FOR namelist IN explist DO block END .)
    LOCAL           reduce using rule 11 (stat -> FOR namelist IN explist DO block END .)
    FUNCTION        reduce using rule 11 (stat -> FOR namelist IN explist DO block END .)
    FOR             reduce using rule 11 (stat -> FOR namelist IN explist DO block END .)
    IF              reduce using rule 11 (stat -> FOR namelist IN explist DO block END .)
    REPEAT          reduce using rule 11 (stat -> FOR namelist IN explist DO block END .)
    WHILE           reduce using rule 11 (stat -> FOR namelist IN explist DO block END .)
    DO              reduce using rule 11 (stat -> FOR namelist IN explist DO block END .)
    (               reduce using rule 11 (stat -> FOR namelist IN explist DO block END .)
    NAME            reduce using rule 11 (stat -> FOR namelist IN explist DO block END .)


state 182

    (12) stat -> FOR name = exp , exp , . exp DO block END
    (42) exp -> . # exp
    (43) exp -> . NOT exp
    (44) exp -> . - exp
    (45) exp -> . exp OR exp
    (46) exp -> . exp AND exp
    (47) exp -> . exp NE exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp GE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LE exp
    (52) exp -> . exp LT exp
    (53) exp -> . exp CONCAT exp
    (54) exp -> . exp % exp
    (55) exp -> . exp ^ exp
    (56) exp -> . exp / exp
    (57) exp -> . exp * exp
    (58) exp -> . exp - exp
    (59) exp -> . exp + exp
    (60) exp -> . tableconstructor
    (61) exp -> . function
    (62) exp -> . VARARG
    (63) exp -> . STRING
    (64) exp -> . NUMBER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . NIL
    (83) tableconstructor -> . { }
    (84) tableconstructor -> . { fieldlist }
    (77) function -> . FUNCTION funcbody
    #               shift and go to state 36
    NOT             shift and go to state 37
    -               shift and go to state 38
    VARARG          shift and go to state 41
    STRING          shift and go to state 42
    NUMBER          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NIL             shift and go to state 46
    {               shift and go to state 47
    FUNCTION        shift and go to state 48

    exp                            shift and go to state 188
    tableconstructor               shift and go to state 39
    function                       shift and go to state 40

state 183

    (13) stat -> FOR name = exp , exp DO . block END
    (4) block -> . chunk
    (1) chunk -> . chunk2 laststat
    (2) chunk2 -> . chunk2 stat optsemi
    (3) chunk2 -> . stat optsemi
    (7) stat -> . LOCAL namelist = explist
    (8) stat -> . LOCAL namelist
    (9) stat -> . LOCAL FUNCTION name funcbody
    (10) stat -> . FUNCTION funcname funcbody
    (11) stat -> . FOR namelist IN explist DO block END
    (12) stat -> . FOR name = exp , exp , exp DO block END
    (13) stat -> . FOR name = exp , exp DO block END
    (14) stat -> . IF exp THEN block elseiflist _else END
    (15) stat -> . REPEAT block UNTIL exp
    (16) stat -> . WHILE exp DO block END
    (17) stat -> . DO block END
    (18) stat -> . varlist = explist
    (32) varlist -> . var
    (33) varlist -> . varlist , var
    (34) var -> . prefixexp . name
    (35) var -> . prefixexp [ exp ]
    (36) var -> . name
    (68) prefixexp -> . ( exp )
    (69) prefixexp -> . functioncall
    (70) prefixexp -> . var
    (37) name -> . NAME
    (71) functioncall -> . prefixexp : name args
    (72) functioncall -> . prefixexp args
    LOCAL           shift and go to state 4
    FUNCTION        shift and go to state 5
    FOR             shift and go to state 7
    IF              shift and go to state 9
    REPEAT          shift and go to state 10
    WHILE           shift and go to state 11
    DO              shift and go to state 8
    (               shift and go to state 15
    NAME            shift and go to state 17

    name                           shift and go to state 6
    block                          shift and go to state 189
    chunk                          shift and go to state 34
    chunk2                         shift and go to state 2
    stat                           shift and go to state 3
    varlist                        shift and go to state 12
    var                            shift and go to state 13
    prefixexp                      shift and go to state 14
    functioncall                   shift and go to state 16

state 184

    (14) stat -> IF exp THEN block elseiflist _else END .
    ;               reduce using rule 14 (stat -> IF exp THEN block elseiflist _else END .)
    BREAK           reduce using rule 14 (stat -> IF exp THEN block elseiflist _else END .)
    RETURN          reduce using rule 14 (stat -> IF exp THEN block elseiflist _else END .)
    LOCAL           reduce using rule 14 (stat -> IF exp THEN block elseiflist _else END .)
    FUNCTION        reduce using rule 14 (stat -> IF exp THEN block elseiflist _else END .)
    FOR             reduce using rule 14 (stat -> IF exp THEN block elseiflist _else END .)
    IF              reduce using rule 14 (stat -> IF exp THEN block elseiflist _else END .)
    REPEAT          reduce using rule 14 (stat -> IF exp THEN block elseiflist _else END .)
    WHILE           reduce using rule 14 (stat -> IF exp THEN block elseiflist _else END .)
    DO              reduce using rule 14 (stat -> IF exp THEN block elseiflist _else END .)
    (               reduce using rule 14 (stat -> IF exp THEN block elseiflist _else END .)
    NAME            reduce using rule 14 (stat -> IF exp THEN block elseiflist _else END .)


state 185

    (24) _else -> ELSE block .
    END             reduce using rule 24 (_else -> ELSE block .)


state 186

    (22) elseif -> ELSEIF exp THEN . block
    (4) block -> . chunk
    (1) chunk -> . chunk2 laststat
    (2) chunk2 -> . chunk2 stat optsemi
    (3) chunk2 -> . stat optsemi
    (7) stat -> . LOCAL namelist = explist
    (8) stat -> . LOCAL namelist
    (9) stat -> . LOCAL FUNCTION name funcbody
    (10) stat -> . FUNCTION funcname funcbody
    (11) stat -> . FOR namelist IN explist DO block END
    (12) stat -> . FOR name = exp , exp , exp DO block END
    (13) stat -> . FOR name = exp , exp DO block END
    (14) stat -> . IF exp THEN block elseiflist _else END
    (15) stat -> . REPEAT block UNTIL exp
    (16) stat -> . WHILE exp DO block END
    (17) stat -> . DO block END
    (18) stat -> . varlist = explist
    (32) varlist -> . var
    (33) varlist -> . varlist , var
    (34) var -> . prefixexp . name
    (35) var -> . prefixexp [ exp ]
    (36) var -> . name
    (68) prefixexp -> . ( exp )
    (69) prefixexp -> . functioncall
    (70) prefixexp -> . var
    (37) name -> . NAME
    (71) functioncall -> . prefixexp : name args
    (72) functioncall -> . prefixexp args
    LOCAL           shift and go to state 4
    FUNCTION        shift and go to state 5
    FOR             shift and go to state 7
    IF              shift and go to state 9
    REPEAT          shift and go to state 10
    WHILE           shift and go to state 11
    DO              shift and go to state 8
    (               shift and go to state 15
    NAME            shift and go to state 17

    block                          shift and go to state 190
    chunk                          shift and go to state 34
    chunk2                         shift and go to state 2
    stat                           shift and go to state 3
    name                           shift and go to state 6
    varlist                        shift and go to state 12
    var                            shift and go to state 13
    prefixexp                      shift and go to state 14
    functioncall                   shift and go to state 16

state 187

    (90) field -> [ exp ] = exp .
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    ;               reduce using rule 90 (field -> [ exp ] = exp .)
    ,               reduce using rule 90 (field -> [ exp ] = exp .)
    }               reduce using rule 90 (field -> [ exp ] = exp .)
    OR              shift and go to state 77
    AND             shift and go to state 78
    NE              shift and go to state 79
    EQ              shift and go to state 80
    GE              shift and go to state 81
    GT              shift and go to state 82
    LE              shift and go to state 83
    LT              shift and go to state 84
    CONCAT          shift and go to state 85
    %               shift and go to state 86
    ^               shift and go to state 87
    /               shift and go to state 88
    *               shift and go to state 89
    -               shift and go to state 90
    +               shift and go to state 91


state 188

    (12) stat -> FOR name = exp , exp , exp . DO block END
    (45) exp -> exp . OR exp
    (46) exp -> exp . AND exp
    (47) exp -> exp . NE exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . GE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LE exp
    (52) exp -> exp . LT exp
    (53) exp -> exp . CONCAT exp
    (54) exp -> exp . % exp
    (55) exp -> exp . ^ exp
    (56) exp -> exp . / exp
    (57) exp -> exp . * exp
    (58) exp -> exp . - exp
    (59) exp -> exp . + exp
    DO              shift and go to state 191
    OR              shift and go to state 77
    AND             shift and go to state 78
    NE              shift and go to state 79
    EQ              shift and go to state 80
    GE              shift and go to state 81
    GT              shift and go to state 82
    LE              shift and go to state 83
    LT              shift and go to state 84
    CONCAT          shift and go to state 85
    %               shift and go to state 86
    ^               shift and go to state 87
    /               shift and go to state 88
    *               shift and go to state 89
    -               shift and go to state 90
    +               shift and go to state 91


state 189

    (13) stat -> FOR name = exp , exp DO block . END
    END             shift and go to state 192


state 190

    (22) elseif -> ELSEIF exp THEN block .
    ELSE            reduce using rule 22 (elseif -> ELSEIF exp THEN block .)
    ELSEIF          reduce using rule 22 (elseif -> ELSEIF exp THEN block .)
    END             reduce using rule 22 (elseif -> ELSEIF exp THEN block .)


state 191

    (12) stat -> FOR name = exp , exp , exp DO . block END
    (4) block -> . chunk
    (1) chunk -> . chunk2 laststat
    (2) chunk2 -> . chunk2 stat optsemi
    (3) chunk2 -> . stat optsemi
    (7) stat -> . LOCAL namelist = explist
    (8) stat -> . LOCAL namelist
    (9) stat -> . LOCAL FUNCTION name funcbody
    (10) stat -> . FUNCTION funcname funcbody
    (11) stat -> . FOR namelist IN explist DO block END
    (12) stat -> . FOR name = exp , exp , exp DO block END
    (13) stat -> . FOR name = exp , exp DO block END
    (14) stat -> . IF exp THEN block elseiflist _else END
    (15) stat -> . REPEAT block UNTIL exp
    (16) stat -> . WHILE exp DO block END
    (17) stat -> . DO block END
    (18) stat -> . varlist = explist
    (32) varlist -> . var
    (33) varlist -> . varlist , var
    (34) var -> . prefixexp . name
    (35) var -> . prefixexp [ exp ]
    (36) var -> . name
    (68) prefixexp -> . ( exp )
    (69) prefixexp -> . functioncall
    (70) prefixexp -> . var
    (37) name -> . NAME
    (71) functioncall -> . prefixexp : name args
    (72) functioncall -> . prefixexp args
    LOCAL           shift and go to state 4
    FUNCTION        shift and go to state 5
    FOR             shift and go to state 7
    IF              shift and go to state 9
    REPEAT          shift and go to state 10
    WHILE           shift and go to state 11
    DO              shift and go to state 8
    (               shift and go to state 15
    NAME            shift and go to state 17

    name                           shift and go to state 6
    block                          shift and go to state 193
    chunk                          shift and go to state 34
    chunk2                         shift and go to state 2
    stat                           shift and go to state 3
    varlist                        shift and go to state 12
    var                            shift and go to state 13
    prefixexp                      shift and go to state 14
    functioncall                   shift and go to state 16

state 192

    (13) stat -> FOR name = exp , exp DO block END .
    ;               reduce using rule 13 (stat -> FOR name = exp , exp DO block END .)
    BREAK           reduce using rule 13 (stat -> FOR name = exp , exp DO block END .)
    RETURN          reduce using rule 13 (stat -> FOR name = exp , exp DO block END .)
    LOCAL           reduce using rule 13 (stat -> FOR name = exp , exp DO block END .)
    FUNCTION        reduce using rule 13 (stat -> FOR name = exp , exp DO block END .)
    FOR             reduce using rule 13 (stat -> FOR name = exp , exp DO block END .)
    IF              reduce using rule 13 (stat -> FOR name = exp , exp DO block END .)
    REPEAT          reduce using rule 13 (stat -> FOR name = exp , exp DO block END .)
    WHILE           reduce using rule 13 (stat -> FOR name = exp , exp DO block END .)
    DO              reduce using rule 13 (stat -> FOR name = exp , exp DO block END .)
    (               reduce using rule 13 (stat -> FOR name = exp , exp DO block END .)
    NAME            reduce using rule 13 (stat -> FOR name = exp , exp DO block END .)


state 193

    (12) stat -> FOR name = exp , exp , exp DO block . END
    END             shift and go to state 194


state 194

    (12) stat -> FOR name = exp , exp , exp DO block END .
    ;               reduce using rule 12 (stat -> FOR name = exp , exp , exp DO block END .)
    BREAK           reduce using rule 12 (stat -> FOR name = exp , exp , exp DO block END .)
    RETURN          reduce using rule 12 (stat -> FOR name = exp , exp , exp DO block END .)
    LOCAL           reduce using rule 12 (stat -> FOR name = exp , exp , exp DO block END .)
    FUNCTION        reduce using rule 12 (stat -> FOR name = exp , exp , exp DO block END .)
    FOR             reduce using rule 12 (stat -> FOR name = exp , exp , exp DO block END .)
    IF              reduce using rule 12 (stat -> FOR name = exp , exp , exp DO block END .)
    REPEAT          reduce using rule 12 (stat -> FOR name = exp , exp , exp DO block END .)
    WHILE           reduce using rule 12 (stat -> FOR name = exp , exp , exp DO block END .)
    DO              reduce using rule 12 (stat -> FOR name = exp , exp , exp DO block END .)
    (               reduce using rule 12 (stat -> FOR name = exp , exp , exp DO block END .)
    NAME            reduce using rule 12 (stat -> FOR name = exp , exp , exp DO block END .)


Conflicts:

shift/reduce conflict for ELSEIF in state 126 resolved as shift